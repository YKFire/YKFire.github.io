<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="数据结构–链表" /><meta name="author" content="YKFire" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="数据结构–链表" /><meta property="og:description" content="数据结构–链表" /><link rel="canonical" href="/posts/List/" /><meta property="og:url" content="/posts/List/" /><meta property="og:site_name" content="YKFire" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-09-09T03:30:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="数据结构–链表" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@YKFire" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"YKFire"},"dateModified":"2022-09-09T03:30:00+00:00","datePublished":"2022-09-09T03:30:00+00:00","description":"数据结构–链表","headline":"数据结构–链表","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/List/"},"url":"/posts/List/"}</script><title>数据结构--链表 | YKFire</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="YKFire"><meta name="application-name" content="YKFire"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/z1.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">YKFire</a></div><div class="site-subtitle font-italic">怕什么真理无穷，进一寸，有一寸的欢喜.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/YKFire" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['1183491613','qq.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>数据结构--链表</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>数据结构--链表</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1662694200" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2022/09/09 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href=""></a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6184 字"> <em>34 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="数据结构链表">数据结构–链表</h1><h2 id="一链表简介"><span class="mr-2">一、链表简介</span><a href="#一链表简介" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，<strong>一个是数据域</strong>，<strong>一个是指针域</strong>（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）</p><p>链接的入口节点称为链表的头结点也就是head</p><p>链表的两种操作方法：①直接使用原来的链表进行操作 ②设置一个虚拟头结点进行操作</p><p>一般设置一个虚拟头结点来操作链表会简单许多</p></blockquote><p><a href="/assets/blog_res/2022-09-09-List.assets/image-20220909104329441.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-09-List.assets/image-20220909104329441.png" alt="链表简介" class="lazyload" data-proofer-ignore></a></p><h2 id="二类型"><span class="mr-2">二、类型</span><a href="#二类型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>链表的几种类型：</p><ul><li>单链表<li>双链表<li>循环链表(也有单双之分)<li>还有一些面试题会出现的特殊链表 如：环形链表、随机链表、扁平化双链表、相交链表、奇偶链表、回文链表..</ul><h2 id="三链表的存储方式"><span class="mr-2">三、链表的存储方式</span><a href="#三链表的存储方式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>数组是在内存中是<strong>连续分布的</strong>，但是链表在内存中可<strong>不是连续分布的</strong></p><p>链表是通过指针域的指针链接在内存中各个节点</p><p>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，<strong>分配机制取决于操作系统的内存管理</strong></p></blockquote><p><a href="/assets/blog_res/2022-09-09-List.assets/image-20220909104248852.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-09-List.assets/image-20220909104248852.png" alt="链表的存储方式" class="lazyload" data-proofer-ignore></a></p><h2 id="四单链表"><span class="mr-2">四、单链表</span><a href="#四单链表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1单链表结构"><span class="mr-2">1、单链表结构</span><a href="#1单链表结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>单链表是最基础的链表结构,其指针域只能指向节点的下一个节点</p><h3 id="2单链表的设计"><span class="mr-2">2、单链表的设计</span><a href="#2单链表的设计" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>在单链表中实现这些功能：</p><ul><li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。<li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</ul></blockquote><p>解题思路：</p><ul><li>单链表的定义：单链表中的节点应该具有两个属性：<code class="language-plaintext highlighter-rouge">val</code> 和 <code class="language-plaintext highlighter-rouge">next</code>。<code class="language-plaintext highlighter-rouge">val</code> 是当前节点的值，<code class="language-plaintext highlighter-rouge">next</code> 是指向下一个节点的指针/引用<li>链表的删除操作：将C节点的next指针指向E节点即可 即C.next = C.next.next; （<strong>关键在于要找到删除节点的前驱</strong>）</ul><p><a href="/assets/blog_res/2022-09-09-List.assets/image-20220909103951131.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-09-List.assets/image-20220909103951131.png" alt="链表的删除操作" class="lazyload" data-proofer-ignore></a></p><ul><li><p>链表的添加操作：将C节点的next指针指向F节点，同时将F节点的next指针指向E节点</p><p>F.next = C.next; C.next = F; (<strong>关键在于要找到插入节点的前驱</strong>)</p></ul><p><a href="/assets/blog_res/2022-09-09-List.assets/image-20220909104639627.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-09-List.assets/image-20220909104639627.png" alt="链表的添加操作" class="lazyload" data-proofer-ignore></a></p><p>代码实现：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
</pre><td class="rouge-code"><pre><span class="c1">//链表节点的定义</span>
<span class="kd">class</span> <span class="nc">ListNode</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">next</span><span class="o">;</span>
    <span class="nc">ListNode</span><span class="o">(){}</span>
    <span class="nc">ListNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">val</span><span class="o">=</span><span class="n">val</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">//链表的定义</span>
<span class="kd">class</span> <span class="nc">MyLinkedList</span> <span class="o">{</span>
    <span class="c1">//size存储链表元素的个数</span>
    <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
    <span class="c1">//虚拟头结点</span>
    <span class="nc">ListNode</span> <span class="n">head</span><span class="o">;</span>

    <span class="c1">//链表初始化,同时创建一个虚拟头结点</span>
    <span class="kd">public</span> <span class="nf">MyLinkedList</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">//获取第index个节点的数值</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//如果index非法，返回-1</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">ListNode</span> <span class="n">currentNode</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="c1">//包含一个虚拟头节点，所以查找第 index+1 个节点</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">currentNode</span> <span class="o">=</span> <span class="n">currentNode</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">currentNode</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//在链表最前面插入一个节点</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addAtHead</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">addAtIndex</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">//在链表的最后插入一个节点</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addAtTail</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">addAtIndex</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span>
    <span class="c1">// 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span>
    <span class="c1">// 如果 index 大于链表的长度，则返回空</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addAtIndex</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span><span class="c1">//index大于链表长度的情况</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span><span class="c1">//index小于0的情况</span>
            <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">size</span><span class="o">++;</span>
        <span class="c1">//找到要插入节点的前驱</span>
        <span class="nc">ListNode</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">ListNode</span> <span class="n">toAdd</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
        <span class="n">toAdd</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">toAdd</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//删除第index个节点</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deleteAtIndex</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">size</span><span class="o">--;</span>
        <span class="nc">ListNode</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="五双链表"><span class="mr-2">五、双链表</span><a href="#五双链表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1双链表结构"><span class="mr-2">1、双链表结构</span><a href="#1双链表结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点</p><p>双链表 既可以向前查询也可以向后查询</p><h3 id="2双链表的设计"><span class="mr-2">2、双链表的设计</span><a href="#2双链表的设计" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>在双链表中实现以下功能：</p><p>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</p></blockquote><p>解题思路：</p><ul><li>双链表的定义：双链表中的节点应该具有三个属性：<code class="language-plaintext highlighter-rouge">val</code> 、<code class="language-plaintext highlighter-rouge">next</code>和<code class="language-plaintext highlighter-rouge">prev</code>。<code class="language-plaintext highlighter-rouge">val</code> 是当前节点的值，<code class="language-plaintext highlighter-rouge">next</code> 是指向下一个节点的指针/引用，<code class="language-plaintext highlighter-rouge">prev</code>是指向上一个节点的指针/引用<li>双链表的删除操作：如果我们想从双链表中删除一个现有的结点 <code class="language-plaintext highlighter-rouge">cur</code>，我们可以简单地将它的前一个结点 <code class="language-plaintext highlighter-rouge">prev</code> 与下一个结点 <code class="language-plaintext highlighter-rouge">next</code> 链接起来 即prev.next = cur.next next.prev = cur.prev</ul><p><a href="/assets/blog_res/2022-09-09-List.assets/image-20220909112745071.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-09-List.assets/image-20220909112745071.png" alt="链表的删除操作" class="lazyload" data-proofer-ignore></a></p><ul><li>双链表的添加操作：如果我们想在现有的结点 <code class="language-plaintext highlighter-rouge">prev</code> 之后插入一个新的结点 <code class="language-plaintext highlighter-rouge">cur</code>，我们可以将此过程分为两个步骤： (<strong>先操作要添加的节点，在操作前后节点</strong>)</ul><p><a href="/assets/blog_res/2022-09-09-List.assets/image-20220909113032086.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-09-List.assets/image-20220909113032086.png" alt="双链表的添加操作" class="lazyload" data-proofer-ignore></a></p><p>代码实现：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
</pre><td class="rouge-code"><pre><span class="c1">//双链表节点的定义</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ListNode</span><span class="o">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">next</span><span class="o">;</span>
    <span class="nc">ListNode</span> <span class="n">prev</span><span class="o">;</span>
    <span class="nc">ListNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">){</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">MyLinkedList</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
    <span class="c1">//创建虚拟头节点和虚拟尾节点</span>
    <span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="n">tail</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">MyLinkedList</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
        <span class="n">tail</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//    </span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//判断index的值是否有效</span>
        <span class="k">if</span><span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="o">){</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">ListNode</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">-</span> <span class="n">index</span><span class="o">){</span><span class="c1">//判断从哪一边开始的效率高</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index</span> <span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span><span class="o">{</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">-</span><span class="n">index</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">curr</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addAtHead</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//创建两个指针等于虚拟头节点和头节点</span>
        <span class="nc">ListNode</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">succ</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">++</span><span class="n">size</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">toAdd</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
        <span class="c1">//添加操作</span>
        <span class="n">toAdd</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span><span class="o">;</span>
        <span class="n">toAdd</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">succ</span><span class="o">;</span>
        <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">toAdd</span><span class="o">;</span>
        <span class="n">succ</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">toAdd</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addAtTail</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//创建两个指针等于虚拟尾结点和尾结点</span>
        <span class="nc">ListNode</span> <span class="n">succ</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
        <span class="o">++</span><span class="n">size</span><span class="o">;</span>
        <span class="c1">//添加操作</span>
        <span class="nc">ListNode</span> <span class="n">toAdd</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
        <span class="n">toAdd</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span><span class="o">;</span>
        <span class="n">toAdd</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">succ</span><span class="o">;</span>
        <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">toAdd</span><span class="o">;</span>
        <span class="n">succ</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">toAdd</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addAtIndex</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//判断index是否有效</span>
        <span class="k">if</span><span class="o">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">size</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">//创建两个指针用于指向index-1节点和index节点</span>
        <span class="nc">ListNode</span> <span class="n">pred</span><span class="o">,</span><span class="n">succ</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">-</span> <span class="n">index</span><span class="o">){</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">succ</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span><span class="o">{</span>
            <span class="n">succ</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">-</span><span class="n">index</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="n">succ</span> <span class="o">=</span> <span class="n">succ</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">succ</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="o">++</span><span class="n">size</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">toAdd</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
        <span class="n">toAdd</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span><span class="o">;</span>
        <span class="n">toAdd</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">succ</span><span class="o">;</span>
        <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">toAdd</span><span class="o">;</span>
        <span class="n">succ</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">toAdd</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deleteAtIndex</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//判断index是否有效</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="c1">//创建两个指针用于指向要删除节点的前一个节点和后一个节点</span>
        <span class="nc">ListNode</span> <span class="n">pred</span><span class="o">,</span> <span class="n">succ</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">-</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">succ</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">succ</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">-</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="n">succ</span> <span class="o">=</span> <span class="n">succ</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">succ</span><span class="o">.</span><span class="na">prev</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//删除操作</span>
        <span class="o">--</span><span class="n">size</span><span class="o">;</span>
        <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">succ</span><span class="o">;</span>
        <span class="n">succ</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="六经典问题"><span class="mr-2">六、经典问题</span><a href="#六经典问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1反转链表"><span class="mr-2">1、反转链表</span><a href="#1反转链表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>给你单链表的头节点 <code class="language-plaintext highlighter-rouge">head</code> ，请你反转链表，并返回反转后的链表。</p><ul><li>链表中节点的数目范围是 <code class="language-plaintext highlighter-rouge">[0, 5000]</code><li><code class="language-plaintext highlighter-rouge">-5000 &lt;= Node.val &lt;= 5000</code></ul></blockquote><p><a href="/assets/blog_res/2022-09-09-List.assets/image-20220909115941573.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-09-List.assets/image-20220909115941573.png" alt="反转链表" class="lazyload" data-proofer-ignore></a></p><p>解题思路：</p><ul><li>本题可以采用<strong>迭代</strong>或者<strong>递归</strong>的方法进行实现，本文采用迭代的解法<li>迭代即暴力解法，<strong>核心思想</strong>就是将链表从头到依次反转<li>我们可以创建三个指针分别用于接受当前的节点(cur)、前一位节点(prev)、下一位节点(next)</ul><p>代码实现：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">reverseList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="nc">ListNode</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span><span class="c1">//创建一个temp指针用于接受下一位节点</span>
            <span class="c1">//反转固定操作</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span><span class="n">prev</span><span class="o">;</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">prev</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="2判断链表是否为环形链表"><span class="mr-2">2、判断链表是否为环形链表</span><a href="#2判断链表是否为环形链表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><ul><li>链表中节点的数目范围是 <code class="language-plaintext highlighter-rouge">[0, 104]</code><li><code class="language-plaintext highlighter-rouge">-105 &lt;= Node.val &lt;= 105</code><li><code class="language-plaintext highlighter-rouge">pos</code> 为 <code class="language-plaintext highlighter-rouge">-1</code> 或者链表中的一个 <strong>有效索引</strong></ul></blockquote><p><a href="/assets/blog_res/2022-09-09-List.assets/image-20220909121046843.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-09-List.assets/image-20220909121046843.png" alt="环形链表" class="lazyload" data-proofer-ignore></a></p><p>解题思路：</p><ul><li>本题可以采用<strong>双指针法</strong>或者<strong>哈希表法</strong>进行解决，哈希表法：使用哈希表进行存储，如果<strong>储存到相同的节点</strong>则代表为环形链表，本文采用更加灵活的双指针法进行解决<li>双指针法：使用快慢指针：slow、fast，slow指针每次走一步，fast指针每次走两次，如果fast指针最终追上slow指针，则代表为环形链表<li>记得考虑链表节点数为0或1的情况<li>使用双指针法必须<strong>注意快指针fast的临界条件，防止出现空指针异常</strong></ul><p>代码实现：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasCycle</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span><span class="c1">//当链表的节点数为0或者1时，则不可能为环形链表</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">fast</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span><span class="c1">//因为快指针fast一次走两步，则必须判断其的下下一个节点是否为空，防止出现空指针异常</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="3判断链表是否为相交链表"><span class="mr-2">3、判断链表是否为相交链表</span><a href="#3判断链表是否为相交链表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p></blockquote><p><a href="/assets/blog_res/2022-09-09-List.assets/image-20220909122424368.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-09-List.assets/image-20220909122424368.png" alt="相交链表" class="lazyload" data-proofer-ignore></a></p><p>解题思路：</p><ul><li>本题同样可以采用<strong>双指针法</strong>和<strong>哈希表法</strong>进行解决，哈希表法的原理即先将一条链表存进哈希表中，在遍历另一条链表查看是否有相同的节点，这里便不多赘述。本题同样采用双指针进行解决<li>使用双指针法：创建两个指针为pA和pB分别指向链表A和链表B的头节点，每次同时更新pA和pB,不为空的时候就指向下一个节点，pA为空时则指向链表B的头节点，pB为空时则指向链表A的头节点，若最终两个指针访问到相同的节点(<strong>a+c</strong>+b=<strong>b+c</strong>+a)则代表为相交链表。<li>a代表链表A从头节点到相交节点的个数，b代表链表B从头节点到相交节点的个数，c代表两条链表共同部分的节点个数<li>如果链表AB出现一条为空链表，则不可能为相交链表</ul><p>代码实现：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">getIntersectionNode</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">headA</span><span class="o">,</span> <span class="nc">ListNode</span> <span class="n">headB</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">headA</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">headB</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">ListNode</span> <span class="n">pA</span> <span class="o">=</span> <span class="n">headA</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">pB</span> <span class="o">=</span> <span class="n">headB</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">pA</span> <span class="o">!=</span> <span class="n">pB</span><span class="o">){</span>
            <span class="n">pA</span> <span class="o">=</span> <span class="n">pA</span> <span class="o">==</span> <span class="kc">null</span><span class="o">?</span> <span class="nl">headB:</span> <span class="n">pA</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> <span class="c1">//采用三元运算符进行简化代码</span>
            <span class="n">pB</span> <span class="o">=</span> <span class="n">pB</span> <span class="o">==</span> <span class="kc">null</span><span class="o">?</span> <span class="nl">headA:</span> <span class="n">pB</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">pA</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="4删除链表的倒数第n个节点"><span class="mr-2">4、删除链表的倒数第N个节点</span><a href="#4删除链表的倒数第n个节点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>给你一个链表，删除链表的倒数第 <code class="language-plaintext highlighter-rouge">n</code> 个结点，并且返回链表的头结点</p><ul><li>链表中结点的数目为 <code class="language-plaintext highlighter-rouge">sz</code><li><code class="language-plaintext highlighter-rouge">1 &lt;= sz &lt;= 30</code><li><code class="language-plaintext highlighter-rouge">0 &lt;= Node.val &lt;= 100</code><li><code class="language-plaintext highlighter-rouge">1 &lt;= n &lt;= sz</code></ul></blockquote><p><a href="/assets/blog_res/2022-09-09-List.assets/image-20220909123849662.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-09-List.assets/image-20220909123849662.png" alt="删除链表的倒数第N个节点" class="lazyload" data-proofer-ignore></a></p><p>解题思路：</p><ul><li><p>本题有三种解题方法：①先获取链表的长度，在根据n求出要删除的节点；②使用栈数据结构：先进后出；③使用双指针(快慢) 本文依然采用双指针进行解决</p><li><p>使用快慢指针进行删除：创建两个指针为first(指向头结点)和second(指向虚拟头结点)，first指针提前向前移动n个位置，当first指针到达null时，second到达要删除的节点的前一个节点 (<strong>下文代码中first、second指针均指向虚拟头节点，那此时做什么改动才能让程序正常实现功能？</strong>)</p><li><p>容易混淆的两个临界条件：</p><p>①while(first.next != null)：代表走到链表的最后一个节点 ②while(first != null)：代表走完整个链表</p></ul><p>代码实现：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ListNode</span> <span class="nf">removeNthFromEnd</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">head</span><span class="o">);</span><span class="c1">//创建一个虚拟头结点</span>
        <span class="nc">ListNode</span> <span class="n">first</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">second</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span><span class="c1">//将快指针提前移动n位</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span><span class="c1">//思考这里的临界条件有什么变化？</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">second</span> <span class="o">=</span> <span class="n">second</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//进行删除操作</span>
        <span class="n">second</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">second</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">ans</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="5判断链表是否为回文链表"><span class="mr-2">5、判断链表是否为回文链表</span><a href="#5判断链表是否为回文链表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>给你一个单链表的头节点 <code class="language-plaintext highlighter-rouge">head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code class="language-plaintext highlighter-rouge">true</code> ；否则，返回 <code class="language-plaintext highlighter-rouge">false</code></p><ul><li>链表中节点数目在范围<code class="language-plaintext highlighter-rouge">[1, 105]</code> 内<li><code class="language-plaintext highlighter-rouge">0 &lt;= Node.val &lt;= 9</code></ul></blockquote><p><a href="/assets/blog_res/2022-09-09-List.assets/image-20220909164106117.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-09-List.assets/image-20220909164106117.png" alt="回文链表" class="lazyload" data-proofer-ignore></a></p><p>解题思路：</p><ul><li>本题有两种解题思路：①将链表存进数组中进行比较，从两边依次向中间进行比较；②使用快慢指针翻转列表进行比较，但最终需要还原链表<li>第①种方法的步骤：<ul><li>复制链表值到数组列表中<li>使用双指针法判断是否为回文并返回结果</ul><li>第②种方法的步骤：<ul><li>找到前半部分链表的尾节点 //创建一个查找尾结点的方法<li>反转后半部分链表 //创建一个反转链表的方法<li>判断是否回文<li>恢复链表<li>返回结果</ul><li>本文采用第②中方法解决问题<li>注意：若使用第①种方法，在判断是否为回文链表的时候，要使用.equals()方法</ul><p>代码实现：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre><td class="rouge-code"><pre><span class="cm">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPalindrome</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 找到前半部分链表的尾节点并反转后半部分链表</span>
        <span class="nc">ListNode</span> <span class="n">firstHalfEnd</span> <span class="o">=</span> <span class="n">endOfFirstHalf</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>
        <span class="nc">ListNode</span> <span class="n">secondHalfStart</span> <span class="o">=</span> <span class="n">reverseList</span><span class="o">(</span><span class="n">firstHalfEnd</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>

        <span class="c1">// 判断是否回文</span>
        <span class="nc">ListNode</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">secondHalfStart</span><span class="o">;</span>
        <span class="kt">boolean</span> <span class="n">result</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">p2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p1</span><span class="o">.</span><span class="na">val</span> <span class="o">!=</span> <span class="n">p2</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>        

        <span class="c1">// 还原链表并返回结果</span>
        <span class="n">firstHalfEnd</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">reverseList</span><span class="o">(</span><span class="n">secondHalfStart</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//反转链表的方法</span>
    <span class="kd">private</span> <span class="nc">ListNode</span> <span class="nf">reverseList</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">ListNode</span> <span class="n">nextTemp</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">curr</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">;</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="o">;</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">nextTemp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">prev</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//查找第一条链表尾结点的方法</span>
    <span class="kd">private</span> <span class="nc">ListNode</span> <span class="nf">endOfFirstHalf</span><span class="o">(</span><span class="nc">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ListNode</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="nc">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">fast</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="6扁平化多级双向链表"><span class="mr-2">6、扁平化多级双向链表</span><a href="#6扁平化多级双向链表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>你会得到一个双链表，其中包含的节点有一个下一个指针、一个前一个指针和一个额外的 子指针 。这个子指针可能指向一个单独的双向链表，也包含这些特殊的节点。这些子列表可以有一个或多个自己的子列表，以此类推，以生成如下面的示例所示的 多层数据结构 。</p><p>给定链表的头节点 head ，将链表 扁平化 ，以便所有节点都出现在单层双链表中。让 curr 是一个带有子列表的节点。子列表中的节点应该出现在扁平化列表中的 curr 之后 和 curr.next 之前 。</p><p>返回 扁平列表的 head 。列表中的节点必须将其 所有 子指针设置为 null 。</p><ul><li>节点数目不超过 <code class="language-plaintext highlighter-rouge">1000</code><li><code class="language-plaintext highlighter-rouge">1 &lt;= Node.val &lt;= 105</code></ul></blockquote><p><a href="/assets/blog_res/2022-09-09-List.assets/image-20220909165913564.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-09-List.assets/image-20220909165913564.png" alt="扁平化多级双向链表" class="lazyload" data-proofer-ignore></a></p><p>解题思路：</p><ul><li>本题要采用深度优先搜索的思想<li>采用递归的方法 dfs()方法：扁平化链表<li>若节点拥有子节点，记得将节点的子节点置为空</ul><p>代码实现：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="cm">/*
// Definition for a Node.
class Node {
    public int val;
    public Node prev;
    public Node next;
    public Node child;
};
*/</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">flatten</span><span class="o">(</span><span class="nc">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">//创建扁平化函数</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">){</span>
        <span class="nc">Node</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
        <span class="c1">//记录链表的最后一个节点</span>
        <span class="nc">Node</span> <span class="n">last</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="c1">//进行操作</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="nc">Node</span> <span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="c1">//如果该节点存在子节点，则优先处理子节点</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">child</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                <span class="nc">Node</span> <span class="n">childLast</span> <span class="o">=</span> <span class="n">dfs</span><span class="o">(</span><span class="n">cur</span><span class="o">.</span><span class="na">child</span><span class="o">);</span> <span class="c1">//采用递归，自己调用自己</span>
                <span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="c1">//将node(当前节点)与child(子链表连接)</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">child</span><span class="o">;</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">child</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
                <span class="c1">//如果next不为空，就将子链表的尾结点(childLast)与next先连</span>
                <span class="k">if</span><span class="o">(</span><span class="n">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
                    <span class="n">childLast</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
                    <span class="n">next</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">childLast</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">//将child置为空</span>
                <span class="n">cur</span><span class="o">.</span><span class="na">child</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="n">last</span> <span class="o">=</span> <span class="n">childLast</span><span class="o">;</span> <span class="c1">//记录当前扁平化链表的最后一位</span>
            <span class="o">}</span>
            <span class="k">else</span><span class="o">{</span>
                <span class="n">last</span> <span class="o">=</span> <span class="n">cur</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="7复制带有随机指针的链表"><span class="mr-2">7、复制带有随机指针的链表</span><a href="#7复制带有随机指针的链表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p><p>例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random –&gt; y 。</p><p>返回复制链表的头节点。</p><p>用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p><p>val：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。 你的代码 只 接受原链表的头节点 head 作为传入参数。</p><ul><li><code class="language-plaintext highlighter-rouge">0 &lt;= n &lt;= 1000</code><li><code class="language-plaintext highlighter-rouge">-104 &lt;= Node.val &lt;= 104</code><li><code class="language-plaintext highlighter-rouge">Node.random</code> 为 <code class="language-plaintext highlighter-rouge">null</code> 或指向链表中的节点。</ul></blockquote><p><a href="/assets/blog_res/2022-09-09-List.assets/image-20220909171536863.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-09-List.assets/image-20220909171536863.png" alt="复制带有随机指针的链表" class="lazyload" data-proofer-ignore></a></p><p>解题思路：</p><ul><li>本题要采用哈希表结构和回溯的算法思想来解决<li>如果是普通链表，我们可以直接按照遍历的顺序创建链表节点。而本题中因为随机指针的存在，当我们拷贝节点时，<strong>「当前节点的随机指针指向的节点」可能还没创建</strong><li>利用回溯的方式，创建一个哈希表用于储存已经拷贝完的节点，如果「当前节点的后继节点」和「当前节点的随机指针指向的节点」还没有被创建，则马上进行创建，并添加进哈希表中，当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。<li>回溯与递归的区别： ①递归是一种算法结构，递归会出现在子程序中，形式上表现为直接或间接的自己调用自己 ②回溯是一种算法思想，<strong>它是用递归实现的</strong>，回溯的过程类似于穷举法，但回溯有“剪枝”功能，即自我判断过程。</ul><p>代码实现：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="cm">/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="c1">//创建哈希表进行储存值</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">,</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">cacheNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">,</span><span class="nc">Node</span><span class="o">&gt;();</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">copyRandomList</span><span class="o">(</span><span class="nc">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">cacheNode</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">head</span><span class="o">)){</span>
            <span class="nc">Node</span> <span class="n">headNew</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="n">cacheNode</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">head</span><span class="o">,</span><span class="n">headNew</span><span class="o">);</span>
            <span class="c1">//此处体现了回溯的思想，即可实现当链表的节点要拷贝random域时所有节点已经被创建出来了</span>
            <span class="n">headNew</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">copyRandomList</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
            <span class="n">headNew</span><span class="o">.</span><span class="na">random</span> <span class="o">=</span> <span class="n">copyRandomList</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">random</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cacheNode</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="七链表问题的常见解题思路"><span class="mr-2">七、链表问题的常见解题思路</span><a href="#七链表问题的常见解题思路" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>双指针法<li>暴力迭代法<li>递归法<li>回溯思想与深度优先搜索思想</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/'>数据结构与算法</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E5%AD%A6%E4%B9%A0/" class="post-tag no-text-decoration" >学习</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%20-%20YKFire&url=%2Fposts%2FList%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%20-%20YKFire&u=%2Fposts%2FList%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FList%2F&text=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%20-%20YKFire" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/ApplyProtocol2/">计算机网络应用层协议(二)</a><li><a href="/posts/ApplyProtocol/">计算机网络应用层协议(一)</a><li><a href="/posts/NetworkOne/">计算机网络发展史(一)</a><li><a href="/posts/NetworkTwo/">计算机网络发展史(二)</a><li><a href="/posts/NetworkThree/">计算机网络发展史(三)</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a> <a class="post-tag" href="/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/">职业规划</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/NetWorkProtocol5/"><div class="card-body"> <em class="small" data-ts="1700394840" data-df="YYYY/MM/DD" > 2023/11/19 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>计算机网络传输层协议(五)</h3><div class="text-muted small"><p> 传输层协议 这是计算机网络传输层的第五篇文章。 TCP 数据流和窗口管理 我们在之前的讲述中知道了可以使用滑动窗口来实现流量控制，也就是说，客户端和服务器可以相互提供数据流信息的交换，数据流的相关信息主要包括报文段序列号、ACK 号和窗口大小。 图中的两个箭头表示数据流方向，数据流方向也就是 TCP 报文段的传输方向。可以看到，每个 TCP 报文段中都包括了序列号、ACK 和...</p></div></div></a></div><div class="card"> <a href="/posts/surroundedByAlgorithms/"><div class="card-body"> <em class="small" data-ts="1700983740" data-df="YYYY/MM/DD" > 2023/11/26 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>完蛋！我被算法包围了</h3><div class="text-muted small"><p> 算法在日常生活的应用 算法听上去很复杂，离我们很遥远。但是以下 10 种算法广泛用于我们的日常生活，包括互联网搜索引擎、社交网络、WiFi、手机甚至卫星。 以下是主宰我们世界的十种算法： 01 排序 我们学习算法一般都是从排序算法开始的，比如冒泡排序、快排序、归并排序、堆排序等。 笔者曾经做过的一个大批量对账系统，就是在第一步使用归并外排序（External MergeSort...</p></div></div></a></div><div class="card"> <a href="/posts/MyFirstBlog/"><div class="card-body"> <em class="small" data-ts="1662124620" data-df="YYYY/MM/DD" > 2022/09/02 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>我的第一篇博客！</h3><div class="text-muted small"><p> 我的第一篇博客！ 这里可以放代码片段噢～ //代码片段 int main(){ hello world; }</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/MyFirstBlog/" class="btn btn-outline-primary" prompt="上一篇"><p>我的第一篇博客！</p></a> <a href="/posts/Git&GitHub/" class="btn btn-outline-primary" prompt="下一篇"><p>Git&GitHub使用</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a> <a class="post-tag" href="/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/">职业规划</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/username">YKFire</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
