<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="计算机网络网络层(一)" /><meta name="author" content="YKFire" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="计算机网络网络层" /><meta property="og:description" content="计算机网络网络层" /><link rel="canonical" href="/posts/NetWorkLayerOne/" /><meta property="og:url" content="/posts/NetWorkLayerOne/" /><meta property="og:site_name" content="YKFire" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-12-31T04:32:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="计算机网络网络层(一)" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@YKFire" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"YKFire"},"dateModified":"2023-12-31T04:32:00+00:00","datePublished":"2023-12-31T04:32:00+00:00","description":"计算机网络网络层","headline":"计算机网络网络层(一)","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/NetWorkLayerOne/"},"url":"/posts/NetWorkLayerOne/"}</script><title>计算机网络网络层(一) | YKFire</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="YKFire"><meta name="application-name" content="YKFire"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/z1.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">YKFire</a></div><div class="site-subtitle font-italic">怕什么真理无穷，进一寸，有一寸的欢喜.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/YKFire" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['1183491613','qq.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>计算机网络网络层(一)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>计算机网络网络层(一)</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1703997120" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2023/12/31 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href=""></a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4320 字"> <em>24 分钟</em>阅读</span></div></div></div><div class="post-content"><h2 id="计算机网络网络层"><span class="mr-2">计算机网络网络层</span><a href="#计算机网络网络层" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>前面我们学习了运输层如何为客户端和服务器输送数据的，提供进程端到端的通信。那么下面我们将学习网络层实际上是怎样实现主机到主机的通信服务的。<strong>几乎每个端系统都有网络层这一部分</strong>。所以，网络层必然是很重要的。下面我将花费大量篇幅来介绍一下计算机网络层的知识。</p><h2 id="网络层概述"><span class="mr-2"><strong>网络层概述</strong></span><a href="#网络层概述" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>网络层是 OSI 参考模型的第三层，它位于传输层和链路层之间，网络层的主要目的是实现两个端系统之间透明的数据传输。</p><p><a href="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121152628590.png" class="popup img-link "><img data-src="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121152628590.png" alt="image-20240121152628590" class="lazyload" data-proofer-ignore></a></p><p>网络层的作用从表面看上去非常简单，即将分组从一台主机移动到另外一台主机。为了实现这个功能，网络层需要两种功能</p><ol><li><strong>转发</strong>：因为在互联网中有很多路由器，这些路由器是构成互联网的基石，为什么这么说呢？因为路由器最重要的一个功能就是<strong>分组转发</strong>，就是靠着这些路由器，才会把一个个数据包通过链路传输给其他节点。当一个分组到达某路由器的一条输入链路时，该路由器会将分组移动到适当的输出链路。<li><strong>路由选择</strong>：当分组由发送方流向接收方时，网络层必须选择这些分组的路径。计算这些路径选择的算法被称为<strong>路由选择算法(routing algorithm)</strong>。</ol><p>也就是说，<strong>转发是指将分组从一个输入链路转移到适当输出链路接口的路由器行为，而路由选择是指确定分组从源到目的地所定位的路径的选择</strong>。我们后面会经常提到转发和路由选择这两个名词。</p><p>那么此处就有一个问题，路由器怎么知道有哪些路径可以选择呢？</p><p>每台路由器都有一个关键的概念就是<strong>转发表(forwarding table)</strong>。路由器通过检查数据包标头中字段的值，来定位转发表中的项来实现转发。标头中的值即对应着转发表中的值，这个值指出了分组将被转发的路由器输出链路。如下图所示</p><p><a href="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121152826706.png" class="popup img-link "><img data-src="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121152826706.png" alt="image-20240121152826706" class="lazyload" data-proofer-ignore></a></p><p>上图中有一个 1001 分组到达路由器后，首先会在转发表中进行索引，然后由路由选择算法决定分组要走的路径。每台路由器都有两种功能：<strong>转发和路由选择</strong>。下面我们就来聊一聊路由器的工作原理。</p><h2 id="路由器工作原理"><span class="mr-2"><strong>路由器工作原理</strong></span><a href="#路由器工作原理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>下面是一个路由器体系结构图，路由器主要是由 4 个组件构成。</p><p><a href="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121152936804.png" class="popup img-link "><img data-src="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121152936804.png" alt="image-20240121152936804" class="lazyload" data-proofer-ignore></a></p><ol><li>输入端口：它有很多功能。输入端口查找/转发功能对路由器的交换功能来说至关重要，由路由器的交换结构来决定输出端口，具体来讲应该是查询转发表来确定的。<li>交换结构：就是将路由器的输入端口连接到它的输出端口。这种交换结构组成了是路由器内部的网络。<li>输出端口：通过交换结构转发分组，并通过物理层和数据链路层的功能传输分组，因此，输出端口作为输入端口执行反向数据链接和物理层功能。<li>路由选择处理器：在路由器内执行路由协议，维护路由表并执行网络管理功能。</ol><p>上面只是这几个组件的简单介绍，其实这几个组件的组成并不像描述的那样简单，下面我们就来深入聊一聊这几个组件。</p><h3 id="输入端口"><span class="mr-2">输入端口</span><a href="#输入端口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>上面介绍了输入端口有很多功能，包括<strong>线路终端、数据处理、查找转发</strong>，其实这些功能在输入端口的内部有相应的模块，输入端口的内部实现如下图所示。</p><p><a href="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121153202635.png" class="popup img-link "><img data-src="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121153202635.png" alt="image-20240121153202635" class="lazyload" data-proofer-ignore></a></p><p>每个输入端口中都有一个路由处理器维护的<strong>路由表的副本</strong>，根据路由处理器进行更新。这个路由表的副本能够使每个输入端口进行切换，而无需经过路由处理器统一处理。<strong>这是一种分散式的切换，这种方式避免了路由选择器统一处理造成转发瓶颈</strong>。</p><p>在输入端口处理能力有限的路由器中，输入端口不会进行交换功能，而是由路由处理器统一处理，然后根据路由表查找并将数据包转发到相应的输出端口。</p><p>一般这种路由器不是单独的路由器，而是工作站或者服务器充当的路由，这种路由器内部中，路由处理器其实就是 CPU，而输入端口其实只是网卡。</p><p>输入端口会根据转发表定位输出端口，然后再会进行分组转发，那么现在就有一个问题，是不是每一个分组都有自己的一条链路呢？如果分组数量非常大，到达亿级的话，也会有亿个输出端口路径吗？</p><p>潜意识告诉我显然不是的，来看下面一个例子。</p><p>下面是三个输入端口对应了转发表中的三个输出链路的示例</p><p><a href="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121153442588.png" class="popup img-link "><img data-src="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121153442588.png" alt="image-20240121153442588" class="lazyload" data-proofer-ignore></a></p><p>可以看到，对于这个例子来说，路由器转发表中不需要那么多条链路，只需要四条就够，即对应输出链路 0 1 2 3 。也就是说，能够使用 4 个转发表就可以实现亿级链路。</p><p>如何实现呢？</p><p>使用这种风格的转发表，路由器分组的地址<strong>前缀(prefix)</strong>会与该表中的表项进行匹配。</p><p><a href="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121153515563.png" class="popup img-link "><img data-src="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121153515563.png" alt="image-20240121153515563" class="lazyload" data-proofer-ignore></a></p><p>如果存在一个匹配项，那么就会转发到对应的链路上，可能不好理解，我举个例子来说吧。</p><p>比如这时有一个分组是 11000011 10010101 00010000 0001100 到达，因为这个分组与 11000011 10010101 00010000 相匹配，所以路由器会转发到 0 链路接口上。如果一个前缀不匹配上面三个输出链路中的一种，那么路由器将向链路接口 3 进行转发。</p><p>路由匹配遵循<strong>最长前缀原则(longest prefix matching rule)</strong>，最长匹配原则说的是如果有两个匹配项一个长一个短的话，就匹配最长的。</p><p>一旦通过查找功能确定了分组的输出端口后，那么该分组就会进入交换结构。在进入交换结构时，如果交换结构正在被使用，就会阻塞新到的分组，等到交换结构调度新的分组。</p><h3 id="交换结构"><span class="mr-2">交换结构</span><a href="#交换结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>交换结构是路由器的核心，通过交换功能把分组从输入端口转发至输出端口，这就是交换结构的主要功能。交换结构有多种形式，包括<strong>通过内存交换、通过总线交换、通过互联网络进行交换</strong>，下面我们分开来探讨一下。</p><ol><li>经过内存交换：最开始的传统计算机就是使用内存交换的，在输入端口和输出端口之间是通过 CPU 进行的。输入端口和输出端口的功能就好像传统操作系统中的 I/O 设备一样。当一个分组到达输入端口时，这个端口会首先以中断的方式向路由选择器发出信号，将分组从输入端口拷贝到内存中。然后路由选择处理器从分组首部中提取目标地址，在转发表中找出适当的输出端口进行转发，同时将分组复制到输出端口的缓存中。</ol><p>这里需要注意一点，如果内存带宽以每秒读取或者写入 B 个数据包，那么总的交换机吞吐量(数据包从输入端口到输出端口的总速率) 必须小于 B/2。</p><p><a href="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121153749277.png" class="popup img-link "><img data-src="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121153749277.png" alt="image-20240121153749277" class="lazyload" data-proofer-ignore></a></p><ol><li>经过总线交换：在这种处理方式中，总线经由输入端口直接将分组传送到输出端口，中间不需要路由选择器的干预。总线的工作流程如下：输入端口给分组分配一个标签，然后分组经由总线发送给所有的输出端口，每个输出端口都会判断标签中的端口和自己的是否匹配，如果匹配的话，那么这个输出端口就会把标签拆掉，这个标签只用于交换机内部跨越总线。如果同时有多个分组到达路由器的话，那么只有一个分组能够被处理，其他分组需要再进入交换结构前等待。</ol><p><a href="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121153840977.png" class="popup img-link "><img data-src="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121153840977.png" alt="image-20240121153840977" class="lazyload" data-proofer-ignore></a></p><ol><li>经过互联网络交换：克服单一、共享式总线带宽限制的一种方法是使用一个更复杂的互联网络。如下图所示</ol><p><a href="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121153911947.png" class="popup img-link "><img data-src="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121153911947.png" alt="image-20240121153911947" class="lazyload" data-proofer-ignore></a></p><h3 id="输出端口处理"><span class="mr-2"><strong>输出端口处理</strong></span><a href="#输出端口处理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>如下图所示，输出端口取出已经存放在输出端口内存中的分组并将其发送到输出链路上。包括选择和去除排队的分组进行传输，执行所需的链路层和物理层的功能。</p><p><a href="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121154205835.png" class="popup img-link "><img data-src="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121154205835.png" alt="image-20240121154205835" class="lazyload" data-proofer-ignore></a></p><p>在输入端口中有等待进入交换的排队队列，而在输出端口中有等待转发的排队队列，排队的位置和程度取决于<strong>流量负载、交换结构</strong>的相对频率和线路速率。</p><p>随着队列的不断增加，会导致路由器的缓存空间被耗尽，进而使没有内存可以存储溢出的队列，致使分组出现丢包，这就是我们说的在网络中丢包或者被路由器丢弃。</p><h2 id="何时出现排队"><span class="mr-2"><strong>何时出现排队</strong></span><a href="#何时出现排队" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>下面我们通过输入端口的排队队列和输出端口的排队队列来介绍一下可能出现的排队情况。</p><h3 id="输入队列"><span class="mr-2"><strong>输入队列</strong></span><a href="#输入队列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>如果交换结构的处理速度没有输入队列到达的速度快，在这种情况下，输入端口将会出现排队情况，到达交换结构前的分组会加入输入端口队列中，以等待通过交换结构传送到输出端口。</p><p>为了描述清楚输入队列，我们假设以下情况：</p><ol><li>使用网络互联的交换方式；<li>假定所有链路的速度相同；<li>在链路中一个分组由输入端口交换到输出端口所花的时间相同，从任意一个输入端口传送到给定的输出端口；<li>分组按照 FCFS 的方式，只要输出端口不同，就可以进行并行传送。但是如果位于任意两个输入端口中的分组是发往同一个目的地的，那么其中的一个分组将被阻塞，而且必须在输入队列中等待，因为交换结构一次只能传输一个到指定端口。</ol><p>如下图所示。</p><p><a href="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121154338384.png" class="popup img-link "><img data-src="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121154338384.png" alt="image-20240121154338384" class="lazyload" data-proofer-ignore></a></p><p>在 A 队列中，输入队列中的两个分组会发送至同一个目的地 X，假设在交换结构正要发送 A 中的分组，在这个时候，C 队列中也有一个分组发送至 X，在这种情况下，C 中发送至 X 的分组将会等待，不仅如此，C 队列中发送至 Y 输出端口的分组也会等待，即使 Y 中没有出现竞争的情况。这种现象叫做<strong>线路前部阻塞(Head-Of-The-Line, HOL)</strong>。</p><h3 id="输出队列"><span class="mr-2"><strong>输出队列</strong></span><a href="#输出队列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们下面讨论输出队列中出现等待的情况。假设交换速率要比输入/输出的传输速率快很多，而且有 N 个输入分组的目的地是转发至相同的输出端口。在这种情况下，在向输出链路发送分组的过程中，将会有 N 个新分组到达传输端口。因为输出端口在一个单位时间内只能传输一个分组，那么这 N 个分组将会等待。然而在等待 N 个分组被处理的过程中，同时又有 N 个分组到达，所以 ，分组队列能够在输出端口形成。这种情况下最终会因为分组数量变的足够大，从而耗尽输出端口的可用内存。</p><p>如果没有足够的内存来缓存分组的话，就必须考虑其他的方式，主要有两种：一种是丢失分组，采用<em>弃尾(drop-tail)</em>的方法；一种是删除一个或多个已经排队的分组，从而来为新的分组腾出空间。</p><p><strong>网络层的策略对 TCP 拥塞控制影响很大的就是路由器的分组丢弃策略。</strong>在最简单的情况下，路由器的队列通常都是按照 FCFS 的规则处理到来的分组。由于队列长度总是有限的，因此当队列已经满了的时候，以后再到达的所有分组（如果能够继续排队，这些分组都将排在队列的尾部）将都被丢弃。这就叫做尾部丢弃策略。</p><p>通常情况下，在缓冲填满之前将其丢弃是更好的策略。</p><p><a href="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121154624346.png" class="popup img-link "><img data-src="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121154624346.png" alt="image-20240121154624346" class="lazyload" data-proofer-ignore></a></p><p>如上图所示，A B C 每个输入端口都到达了一个分组，而且这个分组都是发往 X 的，同一时间只能处理一个分组，然后这时，又有两个分组分别由 A B 发往 X，所以此时有 4 个分组在 X 中进行等待。</p><p><a href="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121154730558.png" class="popup img-link "><img data-src="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121154730558.png" alt="image-20240121154730558" class="lazyload" data-proofer-ignore></a></p><p>等上一个分组被转发完成后，输出端口就会选择在剩下的分组中根据<em>分组调度(packet scheduleer)</em>选择一个分组来进行传输，我们下面就会聊到分组传输。</p><h2 id="分组调度"><span class="mr-2"><strong>分组调度</strong></span><a href="#分组调度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>现在我们来讨论一下分组调度次序的问题，即排队的分组如何经输出链路传输的问题。我们生活中有无数排队的例子，但是我们生活中一般的排队算法都是<em>先来先服务(FCFS)</em>，也是<em>先进先出(FIFO)</em>。</p><h3 id="先进先出"><span class="mr-2"><strong>先进先出</strong></span><a href="#先进先出" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>先进先出就映射为数据结构中的队列，只不过它现在是链路调度规则的排队模型。</p><p><a href="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121154800422.png" class="popup img-link "><img data-src="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121154800422.png" alt="image-20240121154800422" class="lazyload" data-proofer-ignore></a></p><p>FIFO 调度规则按照分组到达输出链路队列的相同次序来选择分组，先到达队列的分组将先会被转发。在这种抽象模型中，如果队列已满，那么弃尾的分组将是队列末尾的后面一个。</p><h3 id="优先级排队"><span class="mr-2"><strong>优先级排队</strong></span><a href="#优先级排队" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>优先级排队是先进先出排队的改良版本，到达输出链路的分组被分类放入输出队列中的优先权类，如下图所示</p><p><a href="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121154823314.png" class="popup img-link "><img data-src="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121154823314.png" alt="image-20240121154823314" class="lazyload" data-proofer-ignore></a></p><p>通常情况下，每个优先级不同的分组有自己的优先级类，每个优先级类有自己的队列，分组传输会首先从优先级高的队列中进行，在同一类优先级的分组之间的选择通常是以 FIFO 的方式完成。</p><h3 id="循环加权公平排队"><span class="mr-2"><strong>循环加权公平排队</strong></span><a href="#循环加权公平排队" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在<strong>循环加权公平规则(round robin queuing discipline)</strong>下，分组像使用优先级那样被分类。然而，在类之间却不存在严格的服务优先权。循环调度器在这些类之间循环轮流提供服务。如下图所示</p><p><a href="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121154905005.png" class="popup img-link "><img data-src="/assets/blog_res/2023-12-31-NetWorkLayer.assets/image-20240121154905005.png" alt="image-20240121154905005" class="lazyload" data-proofer-ignore></a></p><p>在循环加权公平排队中，类 1 的分组被传输，接着是类 2 的分组，最后是类 3 的分组，这算是一个循环，然后接下来又重新开始，又从 1 -&gt; 2 -&gt; 3 这个顺序进行轮询。每个队列也是一个先入先出的队列。</p><p>这是一种所谓的保持工作排队的规则，就是说如果轮询的过程中发现有空队列，输出端口不会等待分组，而是继续轮询下面的队列。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/'>计算机网络</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E5%AD%A6%E4%B9%A0/" class="post-tag no-text-decoration" >学习</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82(%E4%B8%80)%20-%20YKFire&url=%2Fposts%2FNetWorkLayerOne%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82(%E4%B8%80)%20-%20YKFire&u=%2Fposts%2FNetWorkLayerOne%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FNetWorkLayerOne%2F&text=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82(%E4%B8%80)%20-%20YKFire" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/ApplyProtocol2/">计算机网络应用层协议(二)</a><li><a href="/posts/ApplyProtocol/">计算机网络应用层协议(一)</a><li><a href="/posts/NetworkOne/">计算机网络发展史(一)</a><li><a href="/posts/NetworkTwo/">计算机网络发展史(二)</a><li><a href="/posts/NetworkThree/">计算机网络发展史(三)</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a> <a class="post-tag" href="/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/">职业规划</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/surroundedByAlgorithms/"><div class="card-body"> <em class="small" data-ts="1700983740" data-df="YYYY/MM/DD" > 2023/11/26 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>完蛋！我被算法包围了</h3><div class="text-muted small"><p> 算法在日常生活的应用 算法听上去很复杂，离我们很遥远。但是以下 10 种算法广泛用于我们的日常生活，包括互联网搜索引擎、社交网络、WiFi、手机甚至卫星。 以下是主宰我们世界的十种算法： 01 排序 我们学习算法一般都是从排序算法开始的，比如冒泡排序、快排序、归并排序、堆排序等。 笔者曾经做过的一个大批量对账系统，就是在第一步使用归并外排序（External MergeSort...</p></div></div></a></div><div class="card"> <a href="/posts/MyFirstBlog/"><div class="card-body"> <em class="small" data-ts="1662124620" data-df="YYYY/MM/DD" > 2022/09/02 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>我的第一篇博客！</h3><div class="text-muted small"><p> 我的第一篇博客！ 这里可以放代码片段噢～ //代码片段 int main(){ hello world; }</p></div></div></a></div><div class="card"> <a href="/posts/List/"><div class="card-body"> <em class="small" data-ts="1662694200" data-df="YYYY/MM/DD" > 2022/09/09 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>数据结构--链表</h3><div class="text-muted small"><p> 数据结构–链表 一、链表简介 什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域，一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思） 链接的入口节点称为链表的头结点也就是head 链表的两种操作方法：①直接使用原来的链表进行操作 ②设置一个虚拟头结点进行操作 一般设置一个虚拟头结点来操作...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/CommentingSystem/" class="btn btn-outline-primary" prompt="上一篇"><p>评论功能前后端实现方案总结</p></a> <a href="/posts/NetWorkLayerTwo/" class="btn btn-outline-primary" prompt="下一篇"><p>计算机网络网络层(二)</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a> <a class="post-tag" href="/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/">职业规划</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/username">YKFire</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
