---
title: JVM详解
date: 2023-06-25 22:46:00 +0800
categories: [技术科普]
tags: [学习]
pin: true
author: YKFire

toc: true
comments: true

math: false
mermaid: true

typora-root-url: ../../YKFire.github.io

---

> 本文主要讲述面试中常见的JVM考察题，可以帮助读者快速入门了解JVM的相关知识以及重点

## 一、概述

​	JVM（Java Virtual Machine）是一种虚拟机，它是Java平台的核心组成部分。它是一个在物理计算机上模拟的虚拟计算机，可以解释和执行以Java语言编写的程序。JVM提供了一个平台独立的执行环境，使得Java程序可以在任何支持JVM的操作系统上运行，而不需要重新编译。JVM负责将Java源代码编译成字节码，然后通过解释器或即时编译器将字节码转换为机器码并执行。JVM还提供了内存管理、垃圾回收、安全性和异常处理等功能，以确保Java程序的稳定性和安全性。总而言之，JVM充当了Java程序和底层硬件之间的抽象层，为Java应用程序提供了一个可移植和可扩展的运行环境。



## 二、JVM内存

JVM的内存模型有：**程序计数器、虚拟机栈、本地方法栈、堆(运行时数据区)、方法区**。

1. 程序计数器（Program Counter Register）：**每个线程都有自己的程序计数器**，用于指示当前线程执行的字节码指令的行号，以便线程执行时能够回到正确的位置。
2. 虚拟机栈（JVM Stack）：也称为 Java 方法栈，用于存储方法执行时的**局部变量表、操作数栈、动态链接、方法出口等信息**。每个线程在执行一个方法时，都会为该方法分配一个栈帧，并将该栈帧压入虚拟机栈，当方法执行完毕后，虚拟机会将其出栈。
3. 本地方法栈（Native Method Stack）：与虚拟机栈类似，用于存储本地方法的执行信息。
4. 堆（Heap）：**用于存储对象实例，是 JVM 中最大的一块内存区域。**堆是被所有线程共享的，当创建一个新对象时，对象实例存储在堆中，**堆中存储的对象实例都有一个标记用于标记对象是否存活。**垃圾回收器会周期性地回收那些没有被标记为存活的对象。 （新生代即老年代）
5. 方法区（Method Area）：**用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。**方法区也是被所有线程共享的。 (永久代)

运行时常量池（Runtime Constant Pool）：是方法区的一部分，用于存储编译期间生成的各种字面量和符号引用，这些内容在类加载后进入常量池中 （字符串String也被存储其中）

其中，程序计数器、虚拟机栈、本地方法栈是线程私有的，堆、方法区、运行时常量池是线程共享的。



## 三、常见的垃圾回收机制

常见的垃圾回收算法有以下几种类型：

1. 标记-清除算法（Mark-Sweep）：分为标记和清除两个阶段。标记阶段遍历所有活动对象并打上标记，清除阶段将未被标记的对象删除。优点是不需要连续内存空间，缺点是清除后可能会产生内存碎片。
2. 复制算法（Copying）：将可用内存分为两块，只使用其中一块，当这一块满了后，将存活对象复制到另一块未被使用的空间，然后清除使用的那块。优点是简单高效，没有内存碎片问题，缺点是需要额外的空间来存储复制后的对象。
3. 标记-整理算法（Mark-Compact）：在标记阶段与标记-清除算法类似，但在清除阶段将存活对象整理到内存的一端，然后清除边界以外的所有对象。优点是不会产生内存碎片，缺点是比较慢。
4. 分代收集算法（Generational）：根据对象存活的时间将内存分为几个区域，每个区域采用不同的回收策略。一般将新生代分为 Eden 区和两个 Survivor 区，采用复制算法回收；将老年代采用标记-清除或标记-整理算法回收。优点是提高了回收效率，缺点是需要额外的维护成本。

这些算法各有优缺点，适用于不同的场景。标记-清除算法简单，但可能会产生内存碎片；复制算法适用于短时间内产生大量垃圾的场景，但需要额外的空间存储复制后的对象；标记-整理算法不会产生内存碎片，但比较慢；分代收集算法提高了回收效率，但需要额外的维护成本。

对于一个应用程序，选择适合的垃圾回收算法需要综合考虑应用场景、内存需求、性能要求等多个因素，以便达到最佳的效果。



## 四、JVM中什么情况下会进行垃圾回收？

JVM中会在以下情况下进行垃圾回收：

1. 空间分配失败：当JVM需要为新对象分配内存时，如果发现堆空间已经不足，就会触发垃圾回收。
2. 调用System.gc()方法：虽然调用该方法不能保证立即进行垃圾回收，但是它能够提示JVM进行垃圾回收。
3. 堆空间达到了设定的阈值：JVM会根据堆空间使用情况来动态调整垃圾回收的频率和方式。如果堆空间达到了设定的阈值，就会触发垃圾回收。
4. 程序执行过程中：当程序执行过程中，JVM发现某些对象已经不再被引用，就会将这些对象标记为垃圾对象，并在垃圾回收时回收它们的内存空间。

需要注意的是，JVM的垃圾回收机制是自动的，程序员无法直接控制垃圾回收的时机和方式。但是，程序员可以通过一些手段来优化程序的内存使用，如避免创建过多的临时对象、及时关闭不再使用的资源等，以减少垃圾回收的频率和影响。



## 五、双亲委派机制

**双亲委派**模式（Parent-Delegate Model）是 **Java 类加载器**（ClassLoader）在**加载类**时所采用的一种**设计模式**。这种模式的核心思想是：当一个**类加载器**收到**类加载请求**时，首先不会尝试自己加载这个类，而是将**请求委派给其父类加载器**。依次递归，直到**最顶层的启动类加载器**（Bootstrap ClassLoader）；**如果父类加载器无法加载该类，子类加载器才尝试自己去加载。**

**双亲委派模式**的作用主要有以下几点：

1. **避免类的重复加载**：通过委派给父类加载器加载类，可以确保同一个类不会被多个类加载器重复加载。这有助于节省内存资源，并确保类之间的互操作性。
2. **保护 Java 核心类库**：由于双亲委派模式的存在，用户自定义的类加载器无法直接加载 Java 核心类库（如java.lang.Object等）。这有助于确保 Java 核心类库的安全性，防止恶意代码篡改或破坏Java核心类。
3. **维护类加载器的层次结构**：双亲委派模式使得各级类加载器可以按照一定的层次结构来组织和管理。这有助于降低类加载器的复杂性，简化类加载过程。

双亲委派模式在 Java 类加载器中的应用是一种优秀的设计原则，它有助于确保类加载过程的稳定性、安全性和可维护性。

然而，在某些特殊场景下（如 OSGi、Java 热加载等），双亲委派模式可能无法满足需求，**需要采用其他类加载策略**。在这些场景下，开发者需要充分了解类加载机制，以避免产生意外的问题。



## 六、JVM真正的解析顺序

大多的面经给出的都是这样的：

![image-20230710225842560](/assets/blog_res/2023-06-25-JVM.assets/image-20230710225842560.png)

但其实真正的解析顺序：

![image-20230710225922298](/assets/blog_res/2023-06-25-JVM.assets/image-20230710225922298.png)

从图中我们很容易看出:

1. 加载与链接验证的顺序是混合执行的，并非先加载，后链接。之所以大家推崇先加载后链接的说法，是因为大家都觉得“只有加载了才能进行下一步”，因此自然而然的接受了错误的指31
2. 链接中的解析 阶段，其实是不确定核实进行解析的。《Java虚拟机规范》之中并末规定解析阶段发生的具体时间，只要求了在执行ane-warray、checkcastgetfield、getstaticinstanceof、invokedynamic、invokeinterface、invoke-special、invokestatic、invokevirtual.ldc、ldc_w、Idc2_w、multianewarray、new、putield和putstatic这17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。连Java虚拟机规范都未规定，是谁规定了“解析”发生在“准备”之后?为什么非要把“解析”放在准备”之后?难道单独把“解析”拿出来说不行吗?难道仅仅为了图形的完美程度?
3. 链接-验证阶段的“符号引用验证”，一定是发生在“解析"之后的。我们一直在背诵:链接分为3步，验证-准备-解析，几乎都快成为了常识，可遗憾的是:链接-验证的第4种“符号引用验证确是发生在“解析”之后的。