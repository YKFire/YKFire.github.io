---
title: Rabbitmq详解
date: 2023-05-15 20:49:00 +0800
categories: [技术科普]
tags: [学习]
pin: true
author: YKFire

toc: true
comments: true

math: false
mermaid: true

typora-root-url: ../../YKFire.github.io

---



> 本篇文章可以帮助你快速了解消息队列以及对应的应用场景与问题。第八小节结合场景阅读更佳

## 一、基本概述

RabbitMQ是一种开源的消息中间件，基于AMQP（高级消息队列协议）实现。它的基本原理如下：

1. 生产者向RabbitMQ发送消息，消息会被发送到交换机（Exchange）。
2. 交换机接收到消息后，根据规则（Routing Key）将消息路由到一个或多个队列（Queue）。
3. 消费者订阅队列，一旦有消息到达队列，就会将消息取出进行处理。
4. RabbitMQ支持多种消息传递模式，包括点对点（Point-to-Point）和发布/订阅（Publish/Subscribe）。
5. RabbitMQ采用消息确认机制，保证消息的可靠性传递。当消费者处理完消息后，会向RabbitMQ发送确认消息，告知RabbitMQ该消息已经被处理。
6. RabbitMQ还支持消息持久化、消息优先级、消息过期等高级特性，可根据实际需求进行配置。

总之，RabbitMQ提供了一个可靠、灵活、可扩展的消息传递机制，为分布式系统提供了重要的基础设施。



## 二、组成部分

RabbitMQ的组成部分包括以下几个方面：

1. Broker：RabbitMQ的核心组件，负责接收、存储和转发消息。Broker由Exchange、Queue和Binding三个部分组成。
2. Exchange：消息交换机，负责接收生产者发送的消息，并根据Binding规则将消息路由到相应的Queue中。
3. Queue：消息队列，消息在Broker中存储的地方，消费者从队列中获取消息并进行处理。
4. Binding：Exchange和Queue之间的绑定关系，定义了消息的路由规则。
5. Connection：连接，指生产者或消费者与RabbitMQ Broker之间的TCP连接。
6. Channel：通道，每个连接可以创建多个通道，通道是进行消息传递的逻辑通道，可以在通道中进行消息的发送和接收。
7. Virtual Host：虚拟主机，用于将RabbitMQ Broker划分为多个逻辑部分，每个虚拟主机拥有自己的Exchange、Queue和Binding等。
8. Producer：消息生产者，负责向Exchange发送消息。
9. Consumer：消息消费者，负责从Queue中获取消息并进行处理。

以上是RabbitMQ的主要组成部分，每个组件都有自己的作用和功能，共同构成了一个完整的消息传递系统。



## 三、应用场景

- 异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。
- 应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。
- 流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。
- 日志处理 - 解决大量日志传输。
- 消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。



## 四、使用消息队列会带来什么问题？

- **系统可用性降低**本来系统运行好好的，现在你非要加入个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性会降低；
- **系统复杂度提高**加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，复杂性增大。
- **一致性问题**A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。





## 五、AMQP协议是什么？

​	Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。



​	AMQP协议的设计目标是提供一个标准的、可靠的、高效的消息传递机制，以满足不同应用场景下的需求。它支持点对点（Point-to-Point）和发布/订阅（Publish/Subscribe）两种消息传递模式，同时还提供了丰富的消息属性、消息路由规则、消息确认机制等高级特性，可满足复杂的业务需求。





## 六、exchange有哪些类型？

RabbitMQ中的Exchange有四种类型，分别是：Direct Exchange、Fanout Exchange、Topic Exchange和Headers Exchange。

1. Direct Exchange：**直连交换机，它根据消息的Routing Key将消息路由到相应的Queue中。**当Exchange收到一条消息时，会将消息的Routing Key与Binding Key进行比较，如果相同，则将消息路由到对应的Queue中。
2. Fanout Exchange：**扇形交换机，它将消息广播到所有绑定到该Exchange上的Queue中，不考虑消息的Routing Key。**当Exchange收到一条消息时，会将消息路由到所有绑定的Queue中。
3. Topic Exchange：**主题交换机，它根据消息的Routing Key和Binding Key的匹配规则将消息路由到相应的Queue中。**当Exchange收到一条消息时，会将消息的Routing Key与Binding Key进行模糊匹配，如果匹配成功，则将消息路由到对应的Queue中。
4. Headers Exchange：**头交换机，它根据消息的Header信息将消息路由到相应的Queue中。**当Exchange收到一条消息时，会将消息的Header信息与Binding中的参数进行比较，如果匹配成功，则将消息路由到对应的Queue中。

以上四种Exchange类型各有特点，可以根据实际业务需求选择合适的类型。



## 七、queue有哪些类型？

在RabbitMQ中，Queue有以下几种类型：

1. Classic Queue：经典队列，是最常见的队列类型，消息会被顺序存储在队列中，消费者从队列中接收消息。
2. Lazy Queue：懒惰队列，懒惰队列是一种特殊的经典队列，它是为了解决经典队列在存储大量消息时可能会出现的性能问题而设计的。懒惰队列会将消息存储在磁盘中，只有当消息需要被消费者消费时才会从磁盘中读取。
3. Priority Queue：优先级队列，它允许消息设置优先级，高优先级的消息会被优先消费。
4. Quorum Queue：法定队列，是RabbitMQ 3.8版本新增的队列类型，它提供了更高的可靠性和可用性，支持多个节点之间的数据同步，可以在节点故障时快速恢复。
5. TTL Queue：过期队列，消息在队列中存活的时间有限，如果消息在规定时间内没有被消费者消费，则会被自动删除。
6. Shovel Queue：隧道队列，是一种特殊的队列类型，它可以将消息从一个RabbitMQ服务器传输到另一个RabbitMQ服务器。

以上是RabbitMQ中常见的Queue类型，每种类型都有自己的特点和使用场景，可以根据实际业务需求选择合适的类型。



## 八、常见的业务问题

> 核心中的核心 这一模块好好理解

使用RabbitMQ时，常见的业务问题包括：

1、如何保证mq中的消息都会被消费到？

```tex
导致消息无法被消费的原因：
    1.在消息传递过程中，可能会发生消息丢失的情况，导致消息无法被消费者接收
    2.消费者消费失败的场景
    3.消费者消费完成后没有进行确认
    
解决方法：
1、设置消息发送表:在消息传递过程中，设置消息发送表来判断消息是否有发送到rabbitmq之中，同时可以设置重传机制
2、消息持久化：在消息传递过程中，可能会发生RabbitMQ节点宕机等异常情况，导致消息丢失。因此，需要将消息进行持久化，确保即使在RabbitMQ节点宕机的情况下，消息也能够被恢复。
3、消费者的高可用性：消费者也可能会出现宕机等异常情况，导致消息无法被正常消费。因此，需要确保消费者的高可用性，例如采用集群部署、负载均衡等方式，确保即使某个消费者宕机，其他消费者也能够正常消费消息。
4、消息重试机制：如果在消息处理过程中发生异常或错误，需要进行消息重试，确保消息能够被正常消费。
5、TTL机制：可以通过设置消息的TTL（Time To Live）来保证消息不会一直在队列中等待消费，避免消息一直占用队列资源。
6、消息确认机制：消费者在消费完消息后需要向RabbitMQ发送确认消息，告知RabbitMQ消息已经被成功消费。如果RabbitMQ没有收到确认消息，就会认为消息未被消费成功，将会重新发送该消息，直到被消费者确认为止。
```



2、如何保证mq的消息不被重复消费?

```tex
导致消息重复消费的原因：
    由于网络等原因，消息可能会被重复发送，导致消费者重复消费同一条消息

解决方法：
1. 消息去重：在消息消费前，可以先判断该消息是否已经被消费过，如果已经被消费过，则直接忽略该消息，避免重复消费。可以使用 Redis、MySQL 等数据库或者缓存来记录已经消费过的消息。
2. 消息幂等性：在消费消息时，需要保证消息的幂等性，即多次消费同一条消息，最终的结果都是一致的。可以在消息处理过程中使用唯一标识符来保证幂等性，例如使用数据库的主键、全局唯一标识符（UUID）等。
3. 消息确认机制：在消费者消费完消息后，需要向 RabbitMQ 发送确认消息，告知 RabbitMQ 消息已经被成功消费。如果 RabbitMQ 没有收到确认消息，就会认为消息未被消费成功，将会重新发送该消息，从而导致消息重复消费。因此，需要确保消费者正确地发送确认消息。
4. 消息过期时间：在消息发送时，可以设置消息的过期时间，如果消息在规定时间内未被消费，则该消息会过期，从而避免消息被重复消费
```



3、消息堆积

```tex
导致消息堆积的原因：
    当消息的消费速度低于生产速度时，就会导致消息堆积的情况，如果消息堆积过多，会导致系统性能下降
    
解决方法：
1. 增加消费者：可以通过增加消费者的数量，来提高消息的消费速度，从而避免消息在队列中积累过多。可以采用集群部署、负载均衡等方式，实现消费者的高可用性和负载均衡。
2. 增加队列容量：可以通过增加队列的容量，来缓解消息堆积的问题。可以通过 RabbitMQ 的管理界面或者命令行工具来修改队列的容量参数。
3. 设置消息 TTL：可以通过设置消息的 TTL（Time To Live），来避免消息在队列中长时间积累。可以将过期时间设置为较短的时间，从而保证消息能够及时被消费。
4. 设置死信队列：可以通过设置死信队列，来处理一些无法被消费的消息，例如消息过期、队列满等情况。
```



4、垃圾消息问题

```tex
导致垃圾消息问题的原因：
    消费者重复多次发送同样的消息
    
解决方法：
1、为消费者的重传机制设置上限，每次在job重试时，需要先判断一下消息发送表中该消息的发送次数是否达到最大限制，如果达到了，则直接返回。
```



5、RabbitMQ节点宕机

```tex
导致RabbitMQ节点宕机的原因：
    由于硬件故障或其他原因，RabbitMQ节点可能会宕机，导致消息无法被正常处理。 

解决方法：
1、集群部署RabbitMQ 以增加 RabbitMQ 节点，实现其的高可用性，但同时要实现多节点之间的消息共享和负载均衡。
```



## 九、其他概念

### 1、死信队列是干什么的？

死信队列是消息队列中的一种特殊队列，用于存储无法被正常消费的消息。当一个消息在队列中被处理多次仍然无法被消费者处理时，该消息就会被发送到死信队列中。死信队列通常用于处理以下情况：

1. 消息无法被正确处理：例如，消息的格式不正确或者消息所需的资源不足等情况。
2. 消息被拒绝：例如，消费者拒绝处理某些消息，或者消息被设置为不可重试。
3. 消息过期：例如，消息在队列中等待太久，超过了设置的过期时间。

死信队列可以帮助开发人员更好地管理消息队列中的消息，避免消息丢失或者无法被处理的情况，并且可以方便地对无法被处理的消息进行分析和处理。



### 2、消息的TTL是指啥？

消息的TTL（Time-To-Live）**指的是消息在消息队列中的最长存活时间。**当消息在队列中等待时间超过TTL时，消息将被标记为过期并被丢弃或者发送到死信队列中。

TTL通常是在发送消息时设置的，可以根据业务需求设置不同的TTL。例如，对于一些实时性要求较高的消息，可以设置较短的TTL，以确保消息能够及时被消费；对于一些不太紧急的消息，可以设置较长的TTL，以确保消息可以在一定时间内得到处理。

TTL是消息队列中一个非常重要的概念，可以帮助开发人员更好地管理消息队列中的消息，避免消息过期或者无法被处理的情况，并且可以方便地对过期的消息进行分析和处理。
