<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="计算机网络网络层(二)" /><meta name="author" content="YKFire" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="计算机网络网络层" /><meta property="og:description" content="计算机网络网络层" /><link rel="canonical" href="/posts/NetWorkLayerTwo/" /><meta property="og:url" content="/posts/NetWorkLayerTwo/" /><meta property="og:site_name" content="YKFire" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-01-07T07:51:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="计算机网络网络层(二)" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@YKFire" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"YKFire"},"dateModified":"2024-01-07T07:51:00+00:00","datePublished":"2024-01-07T07:51:00+00:00","description":"计算机网络网络层","headline":"计算机网络网络层(二)","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/NetWorkLayerTwo/"},"url":"/posts/NetWorkLayerTwo/"}</script><title>计算机网络网络层(二) | YKFire</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="YKFire"><meta name="application-name" content="YKFire"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/z1.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">YKFire</a></div><div class="site-subtitle font-italic">怕什么真理无穷，进一寸，有一寸的欢喜.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/YKFire" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['1183491613','qq.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>计算机网络网络层(二)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>计算机网络网络层(二)</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1704613860" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2024/01/07 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href=""></a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6635 字"> <em>36 分钟</em>阅读</span></div></div></div><div class="post-content"><h2 id="计算机网络网络层"><span class="mr-2">计算机网络网络层</span><a href="#计算机网络网络层" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>这是计算机网络之网络层的第二篇文章。</p><h2 id="ip-协议"><span class="mr-2"><strong>IP 协议</strong></span><a href="#ip-协议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>路由器对分组进行转发后，就会把数据传到网络上，数据包最终是要传递到客户端或者服务器上的，那么数据包怎么知道要发往哪里呢？起到关键作用的就是 IP 协议。</p><p>IP 主要分为三个部分，分别是 <strong>IP 寻址、路由和分包组包</strong>。下面我们主要围绕这三点进行阐述。</p><h3 id="ip-地址"><span class="mr-2"><strong>IP 地址</strong></span><a href="#ip-地址" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>既然一个数据包要在网络上传输，那么肯定需要知道这个数据包到底发往哪里，也就是说需要一个目标地址信息，<strong>IP 地址就是连接网络中的所有主机进行通信的目标地址</strong>。因此在网络上的每个主机都需要有自己的 IP 地址。</p><p><a href="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121155356465.png" class="popup img-link "><img data-src="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121155356465.png" alt="image-20240121155356465" class="lazyload" data-proofer-ignore></a></p><p>在 IP 数据包发送的链路中，有可能链路非常长，比如说由中国发往美国的一个数据包，由于网络抖动等一些意外因素可能会导致数据包丢失，这时我们在这条链路中会放入一些中转站，一方面能够判断数据包是否丢失，另一方面能够控制数据包的转发，这个中转站就是我们前面聊过的路由器，这个转发过程就是路由控制。</p><p><strong>路由控制(Routing)</strong>是指将分组数据发送到最终目标地址的功能，即使网络复杂多变，也能够通过路由控制到达目标地址。因此一个数据包能否到达目标主机，关键就在于路由控制。</p><p>这里需要解释一个词就是 跳的概念，由于在一条从源地址到目标地址的链路中会布满很多路由器，路由器需要将一个数据包传送到另一个路由器，这样路由器和路由器之间的数据包传送就是跳，比如你和隔壁老王通信，中间就可能会经过老刘，于是你的数据包就会从你跳到老刘家，然后从老刘家跳到老王家。</p><p>那么一跳的范围有多大呢？</p><p><strong>一跳是指从源 MAC 地址到目标 MAC 地址之间传输帧的区间</strong>，这里引出一个新的名词，MAC 地址是啥？</p><p>MAC 地址指的就是计算机的<strong>物理地址(Physical Address)</strong>，它是用来确认网络设备位置的地址。在 OSI 网络模型中，网络层负责 IP 地址的定位，而数据链路层负责 MAC 地址的定位。MAC 地址用于在网络中唯一标示一个网卡，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的 MAC 地址，<strong>也就是说 MAC 地址和网卡是紧密联系在一起的。</strong></p><p>路由器的每一跳都需要询问当前中转的路由器，下一跳应该跳到哪里，从而跳转到目标地址。而不是数据报刚开始发送后，网络中所有的通路都会显示出来，这种多次跳转也叫做多跳路由。</p><h4 id="ip-地址定义"><span class="mr-2"><strong>IP 地址定义</strong></span><a href="#ip-地址定义" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>现如今有两个版本的 IP 地址，IPv4 和 IPv6，我们首先探讨一下现如今还在广泛使用的 IPv4 地址，后面再考虑 IPv6 。</p><p>IPv4 由 32 位正整数来表示，在计算机内部会转化为二进制来处理，但是二进制不符合人类阅读的习惯，所以我们根据易读性的原则把 32 位的 IP 地址以 8 位为一组，分成四组，每组之间以 . 进行分割，再将每组转换为十进制数。如下图所示</p><p><a href="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121155714399.png" class="popup img-link "><img data-src="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121155714399.png" alt="image-20240121155714399" class="lazyload" data-proofer-ignore></a></p><p>那么上面这个 32 位的 IP 地址就会被转换为十进制的 156.197.1.1。</p><p>除此之外，从图中我们还可以得到如下信息</p><p>每个这样 8 位位一组的数字，自然是非负数，其取值范围是 [0,255]。</p><p>IP 地址的总个数有 2^32 次幂个，这个数值算下来是 4294967296 ，大概能允许 43 亿台设备连接到网络。实际上真的如此吗？</p><p>实际上 IP 不会以主机的个数来配置的，而是根据设备上的 网卡(NIC) 进行配置，每一块网卡都会设置一个或者多个 IP 地址，而且通常一台路由器会有至少两块网卡，所以可以设置两个以上的 IP 地址，所以主机的数量远远达不到 43 亿。</p><p><a href="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121155815060.png" class="popup img-link "><img data-src="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121155815060.png" alt="image-20240121155815060" class="lazyload" data-proofer-ignore></a></p><h4 id="ip-地址构造和分类"><span class="mr-2"><strong>IP 地址构造和分类</strong></span><a href="#ip-地址构造和分类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>IP 地址由 <strong>网络标识 和 主机标识 两部分组成</strong>，网络标识代表着网络地址，主机标识代表着主机地址。网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址都不重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的 主机标识 则不允许在同一网段内重复出现。</p><p>举个例子来说：比如说我在石家庄(好像不用比如昂)，我所在的小区的某一栋楼就相当于是网络标识，某一栋楼的第几户就相当于是我的主机标识，当然如果你有整栋楼的话，那就当我没说。你可以通过xx省xx市xx区xx路xx小区xx栋来定位我的网络标识，这一栋的第几户就相当于是我的主机标识。</p><p>IP 地址分为四类，分别是 <strong>A类、B类、C类、D类、E类</strong>，它会根据 IP 地址中的第 1 位到第 4 位的比特对网络标识和主机标识进行分类。</p><ol><li>A 类：(1.0.0.0 - 126.0.0.0)（默认子网掩码：255.0.0.0 或 0xFF000000）第一个字节为网络号，后三个字节为主机号。该类 IP 地址的最前面为 0 ，所以地址的网络号取值于 1~126 之间。一般用于大型网络。<li>B 类：(128.0.0.0 - 191.255.0.0)（默认子网掩码：255.255.0.0 或 0xFFFF0000）前两个字节为网络号，后两个字节为主机号。该类 IP 地址的最前面为 10 ，所以地址的网络号取值于 128~191 之间。一般用于中等规模网络。<li>C 类：(192.0.0.0 - 223.255.255.0)（子网掩码：255.255.255.0 或 0xFFFFFF00）前三个字节为网络号，最后一个字节为主机号。该类 IP 地址的最前面为 110 ，所以地址的网络号取值于 192~223 之间。一般用于小型网络。<li>D 类：是多播地址。该类 IP 地址的最前面为 1110 ，所以地址的网络号取值于 224~239 之间。一般用于多路广播用户。<li>E 类：是保留地址。该类 IP 地址的最前面为 1111 ，所以地址的网络号取值于 240~255 之间。</ol><p>为了方便理解，我画了一张 IP 地址分类图，如下所示</p><p><a href="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121160149603.png" class="popup img-link "><img data-src="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121160149603.png" alt="image-20240121160149603" class="lazyload" data-proofer-ignore></a></p><p>根据不同的 IP 范围，有下面不同的地总空间分类</p><p><a href="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121160216582.png" class="popup img-link "><img data-src="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121160216582.png" alt="image-20240121160216582" class="lazyload" data-proofer-ignore></a></p><h4 id="子网掩码"><span class="mr-2"><strong>子网掩码</strong></span><a href="#子网掩码" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>子网掩码(subnet mask)</strong>又叫做网络掩码，它是一种用来指明<strong>一个 IP 地址的哪些位标识的是主机所在的网络</strong>。子网掩码是一个 32位 地址，用于屏蔽 IP 地址的一部分以<strong>区别网络标识和主机标识</strong>。</p><p>一个 IP 地址只要确定了其分类，也就确定了它的<strong>网络标识和主机标识</strong>，由此，各个分类所表示的网络标识范围如下</p><p><a href="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121160311839.png" class="popup img-link "><img data-src="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121160311839.png" alt="image-20240121160311839" class="lazyload" data-proofer-ignore></a></p><p>用 1 表示 IP 网络地址的比特范围，0 表示 IP 主机地址的范围。将他们用十进制表示，那么这三类的表示如下</p><p><a href="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121160411031.png" class="popup img-link "><img data-src="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121160411031.png" alt="image-20240121160411031" class="lazyload" data-proofer-ignore></a></p><h4 id="保留地址"><span class="mr-2"><strong>保留地址</strong></span><a href="#保留地址" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>在IPv4 的几类地址中，有几个保留的地址空间不能在互联网上使用。这些地址用于特殊目的，不能在局域网外部路由。</p><p><a href="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121160431380.png" class="popup img-link "><img data-src="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121160431380.png" alt="image-20240121160431380" class="lazyload" data-proofer-ignore></a></p><h3 id="ip-协议版本"><span class="mr-2"><strong>IP 协议版本</strong></span><a href="#ip-协议版本" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>目前，全球 Internet 中共存有两个IP版本：<strong>IP 版本 4（IPv4）</strong>和 <strong>IP 版本6（IPv6）</strong>。 IP 地址由二进制值组成，可驱动 Internet 上所有数据的路由。 <strong>IPv4 地址的长度为 32 位，而 IPv6 地址的长度为 128 位。</strong></p><p>Internet IP 资源由 Internet 分配号码机构（IANA）分配给区域 Internet 注册表（RIR），例如 APNIC，该机构负责根 DNS ，IP 寻址和其他 Internet 协议资源。</p><p>下面我们就一起认识一下 IP 协议中非常重要的两个版本 IPv4 和 IPv6。</p><h3 id="ipv4"><span class="mr-2"><strong>IPv4</strong></span><a href="#ipv4" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>IPv4 的全称是 <em>Internet Protocol version 4</em>，是 Internet 协议的第四版。IPv4 是一种无连接的协议，这个协议会尽最大努力交付数据包，也就是说它不能保证任何数据包能到达目的地，也不能保证所有的数据包都会按照正确的顺序到达目标主机，这些都是由上层比如传输控制协议控制的。也就是说，单从 IP 看来，这是一个不可靠的协议。</p><p>前面我们讲过<strong>网络层分组被称为数据报</strong>，所以我们接下来的叙述也会围绕着数据报展开。</p><p>IPv4 的数据报格式如下</p><p><a href="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121160527064.png" class="popup img-link "><img data-src="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121160527064.png" alt="image-20240121160527064" class="lazyload" data-proofer-ignore></a></p><p>IPv4 数据报中的关键字及其解释：</p><ol><li>版本字段(Version)占用 4 bit，通信双方使用的版本必须一致，对于 IPv4 版本来说，字段值是 4。<li>首部长度(Internet Header Length) 占用 4 bit，首部长度说明首部有多少 32 位(4 字节)。由于 IPv4 首部可能包含不确定的选项，因此这个字段被用来确定数据的偏移量。大多数 IP 不包含这个选项，所以一般首部长度设置为 5， 数据报为 20 字节 。<li>服务类型(Differential Services Codepoint，DSCP) 占用 6 bit，以便使用不同的 IP 数据报，比如一些低时延、高吞吐量和可靠性的数据报。服务类型如下表所示。</ol><p><a href="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121164426747.png" class="popup img-link "><img data-src="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121164426747.png" alt="image-20240121164426747" class="lazyload" data-proofer-ignore></a></p><ol><li>拥塞通告(Explicit Congestion Notification，ECN) 占用 2 bit，它允许在不丢弃报文的同时通知对方网络拥塞的发生。ECN 是一种可选的功能，仅当两端都支持并希望使用，且底层网络支持时才被使用。最开始 DSCP 和 ECN 统称为 TOS，也就是区分服务，但是后来被细化为了 DSCP 和 ECN。<li>数据包长度(Total Length) 占用 16 bit，这 16 位是包括在数据在内的总长度，理论上数据的总长度为 2 的 16 次幂 - 1，最大长度是 65535 字节，但是实际上数据报很少有超过 1500 字节的。IP 规定所有主机都必须支持最小 576 字节的报文，但大多数现代主机支持更大的报文。当下层的数据链路协议的最大传输单元（MTU）字段的值小于 IP 报文长度时，报文就必须被分片。<li>标识符(Identification) 占用 16 bit，这个字段用来标识所有的分片，因为分片不一定会按序到达，所以到达目标主机的所有分片会进行重组，每产生一个数据报，计数器加1，并赋值给此字段。<li>标志(Flags) 占用 3 bit，标志用于控制和识别分片，这 3 位分别是<li>0 位：保留，必须为0；<li>1 位：禁止分片（Don’t Fragment，DF），当 DF = 0 时才允许分片；<li>2 位：更多分片（More Fragment，MF），MF = 1 代表后面还有分片，MF = 0 代表已经是最后一个分片。<li>如果 DF 标志被设置为 1 ，但是路由要求必须进行分片，那么这条数据报回丢弃<li>分片偏移(Fragment Offset) 占用 13 位，它指明了每个分片相对于原始报文开头的偏移量，以 8 字节作单位。<li>存活时间(Time To Live，TTL) 占用 8 位，存活时间避免报文在互联网中迷失，比如陷入路由环路。存活时间以秒为单位，但小于一秒的时间均向上取整到一秒。在现实中，这实际上成了一个跳数计数器：报文经过的每个路由器都将此字段减 1，当此字段等于 0 时，报文不再向下一跳传送并被丢弃，这个字段最大值是 255。<li>协议(Protocol) 占用 8 位，这个字段定义了报文数据区使用的协议。协议内容可以在 https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml 官网上获取。<li>首部校验和(Header Checksum) 占用 16 位，首部校验和会对字段进行纠错检查，在每一跳中，路由器都要重新计算出的首部检验和并与此字段进行比对，如果不一致，此报文将会被丢弃。<li>源地址(Source address) 占用 32 位，它是 IPv4 地址的构成条件，源地址指的是数据报的发送方<li>目的地址(Destination address)占用 32 位，它是 IPv4 地址的构成条件，目标地址指的是数据报的接收方<li>选项(Options) 是附加字段，选项字段占用 1 - 40 个字节不等，一般会跟在目的地址之后。如果首部长度 &gt; 5，就应该考虑选项字段。<li>数据 不是首部的一部分，因此并不被包含在首部检验和中。</ol><p>在 IP 发送的过程中，每个数据报的大小是不同的，每个链路层协议能承载的网络层分组也不一样，有的协议能够承载大数据报，有的却只能承载很小的数据报，不同的链路层能够承载的数据报大小如下。</p><p><a href="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121164651190.png" class="popup img-link "><img data-src="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121164651190.png" alt="image-20240121164651190" class="lazyload" data-proofer-ignore></a></p><h4 id="ipv4-分片"><span class="mr-2"><strong>IPv4 分片</strong></span><a href="#ipv4-分片" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>一个链路层帧能承载的最大数据量叫做<strong>最大传输单元(Maximum Transmission Unit, MTU)</strong>，每个 IP 数据报封装在链路层帧中从一台路由器传到下一台路由器。因为每个链路层所支持的最大 MTU 不一样，当数据报的大小超过 MTU 后，会在链路层进行分片，每个数据报会在链路层单独封装，每个较小的片都被称为 片(fragement)。</p><p><a href="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121164751839.png" class="popup img-link "><img data-src="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121164751839.png" alt="image-20240121164751839" class="lazyload" data-proofer-ignore></a></p><p>每个片在到达目的地后会进行重组，准确的来说是在运输层之前会进行重组，TCP 和 UDP 都会希望发送完整的、未分片的报文，出于性能的原因，分片重组不会在路由器中进行，而是会在目标主机中进行重组。</p><p>当目标主机收到从发送端发送过来的数据报后，它需要确定这些数据报中的分片是否是由源数据报分片传递过来的，如果是的话，还需要确定何时收到了分片中的最后一片，并且这些片会如何拼接一起成为数据报。</p><p>针对这些潜在的问题，IPv4 设计者将 <strong>标识、标志和片偏移</strong>放在 IP 数据报首部中。当生成一个数据报时，发送主机会为该数据报设置源和目的地址的同时贴上标识号。发送主机通常将它发送的每个数据报的标识 + 1。当某路由器需要对一个数据报分片时，形成的每个数据报具有初始数据报的<strong>源地址、目标地址和标识号</strong>。当目的地从同一发送主机收到一系列数据报时，它能够检查数据报的标识号以确定哪些数据是由源数据报发送过来的。由于 IP 是一种不可靠的服务，分片可能会在网路中丢失，鉴于这种情况，通常会把分片的最后一个比特设置为 0 ，其他分片设置为 1，同时使用偏移字段指定分片应该在数据报的哪个位置。</p><h3 id="ipv6"><span class="mr-2"><strong>IPv6</strong></span><a href="#ipv6" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>随着端系统接入的越来越多，IPv4 已经无法满足分配了，所以，IPv6 应运而生，IPv6 就是为了<strong>解决 IPv4 的地址耗尽问题而被标准化的网际协议。</strong>IPv4 的地址长度为 4 个 8 字节，即 32 比特， 而 IPv6 的地址长度是原来的四倍，也就是 128 比特，一般写成 8 个 16 位字节。</p><p>从 IPv4 切换到 IPv6 及其耗时，需要将网络中所有的主机和路由器的 IP 地址进行设置，在互联网不断普及的今天，替换所有的 IP 是一个工作量及其庞大的任务。我们后面会说。</p><p>我们先来看一下 IPv6 的地址是怎样的</p><p><a href="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121165402809.png" class="popup img-link "><img data-src="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121165402809.png" alt="image-20240121165402809" class="lazyload" data-proofer-ignore></a></p><ol><li>版本与 IPv4 一样，版本号由 4 bit 构成，IPv6 版本号的值为 6。<li>流量类型(Traffic Class) 占用 8 bit，它就相当于 IPv4 中的服务类型(Type Of Service)。<li>流标签(Flow Label) 占用 20 bit，这 20 比特用于标识一条数据报的流，能够对一条流中的某些数据报给出优先权，或者它能够用来对来自某些应用的数据报给出更高的优先权，只有流标签、源地址和目标地址一致时，才会被认为是一个流。<li>有效载荷长度(Payload Length) 占用 16 bit，这 16 比特值作为一个无符号整数，它给出了在 IPv6 数据报中跟在鼎昌 40 字节数据报首部后面的字节数量。<li>下一个首部(Next Header) 占用 8 bit，它用于标识数据报中的内容需要交付给哪个协议，是 TCP 协议还是 UDP 协议。<li>跳限制(Hop Limit) 占用 8 bit，这个字段与 IPv4 的 TTL 意思相同。数据每经过一次路由就会减 1，减到 0 则会丢弃数据。<li>源地址(Source Address) 占用 128 bit (8 个 16 位 )，表示发送端的 IP 地址。<li>目标地址(Destination Address) 占用 128 bit (8 个 16 位 )，表示接收端 IP 地址。</ol><p>可以看到，相较于 IPv4 ，IPv6 取消了下面几个字段</p><ol><li><strong>标识符、标志和比特偏移</strong>：IPv6 不允许在中间路由器上进行分片和重新组装。这种操作只能在端系统上进行，IPv6 将这个功能放在端系统中，加快了网络中的转发速度。<li><strong>首部校验和</strong>：因为在运输层和数据链路执行了报文段完整性校验工作，IP 设计者大概觉得在网络层中有首部校验和比较多余，所以去掉了。<strong>IP 更多专注的是快速处理分组数据</strong>。<li><strong>选项字段</strong>：选项字段不再是标准 IP 首部的一部分了，但是它并没有消失，而是可能出现在 IPv6 的扩展首部，也就是下一个首部中。</ol><h4 id="ipv6-扩展首部"><span class="mr-2"><strong>IPv6 扩展首部</strong></span><a href="#ipv6-扩展首部" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>IPv6 首部长度固定，无法将选项字段加入其中，取而代之的是 IPv6 使用了扩展首部。</p><p>扩展首部通常介于 IPv6 首部与 TCP/UDP 首部之间，在 IPv4 中可选长度固定为 40 字节，在 IPv6 中没有这样的限制。IPv6 的扩展首部可以是任意长度。扩展首部中还可以包含扩展首部协议和下一个扩展字段。</p><p>IPv6 首部中没有标识和标志字段，<strong>对 IP 进行分片时，需要使用到扩展首部</strong>。</p><p><a href="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121165752087.png" class="popup img-link "><img data-src="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121165752087.png" alt="image-20240121165752087" class="lazyload" data-proofer-ignore></a></p><p>具体的扩展首部表如下所示</p><p><a href="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121165803516.png" class="popup img-link "><img data-src="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121165803516.png" alt="image-20240121165803516" class="lazyload" data-proofer-ignore></a></p><p>下面我们来看一下 IPv6 都有哪些特点</p><h4 id="ipv6-特点"><span class="mr-2"><strong>IPv6 特点</strong></span><a href="#ipv6-特点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>IPv6 的特点在 IPv4 中得以实现，但是即便实现了 IPv4 的操作系统，也未必实现了 IPv4 的所有功能。而 IPv6 却将这些功能大众化了，也就表明这些功能在 IPv6 已经进行了实现，这些功能主要有</p><ol><li><strong>地址空间变得更大</strong>：这是 IPv6 最主要的一个特点，即支持更大的地址空间。<li><strong>精简报文结构</strong>: IPv6 要比 IPv4 精简很多，IPv4 的报文长度不固定，而且有一个不断变化的选项字段；IPv6 报文段固定，并且将选项字段，分片的字段移到了 IPv6 扩展头中，这就极大的精简了 IPv6 的报文结构。<li><strong>实现了自动配置</strong>：IPv6 支持其主机设备的<strong>状态和无状态</strong>自动配置模式。这样，没有 DHCP 服务器不会停止跨段通信。<li><strong>层次化的网络结构</strong>： IPv6 不再像 IPv4 一样按照 A、B、C等分类来划分地址，而是通过 <strong>IANA -&gt; RIR -&gt; ISP 这样的顺序</strong>来分配的。IANA 是国际互联网号码分配机构，RIR 是区域互联网注册管理机构，ISP 是一些运营商（例如电信、移动、联通）。<li><strong>IPSec</strong>：IPv6 的扩展报头中有一个认证报头、封装安全净载报头，这两个报头是 IPsec 定义的。通过这两个报头网络层自己就可以实现端到端的安全，而无需像 IPv4 协议一样需要其他协议的帮助。<li><strong>支持任播</strong>：IPv6 引入了一种新的寻址方式，称为任播寻址。</ol><h4 id="ipv6-地址"><span class="mr-2"><strong>IPv6 地址</strong></span><a href="#ipv6-地址" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>我们知道，IPv6 地址长度为 128 位，他所能表示的范围是 2 ^ 128 次幂，这个数字非常庞大，几乎涵盖了你能想到的所有主机和路由器，那么 IPv6 该如何表示呢？</p><p>一般我们将 128 比特的 IP 地址以每 16 比特为一组，并用 : 号进行分隔，如果出现连续的 0 时还可以将 0 省略，并用 :: 两个冒号隔开，记住，<strong>一个 IP 地址只允许出现一次两个连续的冒号(IPV6)。</strong></p><p>下面是一些 IPv6 地址的示例</p><ol><li>二进制数表示</ol><p><a href="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121165957275.png" class="popup img-link "><img data-src="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121165957275.png" alt="image-20240121165957275" class="lazyload" data-proofer-ignore></a></p><ol><li>用十六进制数表示</ol><p><a href="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121170009587.png" class="popup img-link "><img data-src="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121170009587.png" alt="image-20240121170009587" class="lazyload" data-proofer-ignore></a></p><ol><li>出现两个冒号的情况</ol><p><a href="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121170031317.png" class="popup img-link "><img data-src="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121170031317.png" alt="image-20240121170031317" class="lazyload" data-proofer-ignore></a></p><p>如上图所示，A120 和 4CD 中间的 0 被 :: 所取代了。</p><h2 id="如何从-ipv4-迁移到-ipv6"><span class="mr-2"><strong>如何从 IPv4 迁移到 IPv6</strong></span><a href="#如何从-ipv4-迁移到-ipv6" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们上面聊了聊 IPv4 和 IPv6 的报文格式、报文含义是什么、以及 IPv4 和 IPv6 的特征分别是什么，看完上面的内容，你已经知道了 IPv4 现在马上就变的不够用了，而且随着 IPv6 的不断发展和引用，虽然新型的 IPv6 可以做到向后兼容，即 IPv6 可以收发 IPv4 的数据报，但是<strong>已经部署的具有 IPv4 能力的系统却不能够处理 IPv6 数据报</strong>。所以 IPv4 噬需迁移到 IPv6，迁移并不意味着将 IPv4 替换为 IPv6。这仅意味着同时启用 IPv6 和 IPv4。</p><p>那么现在就有一个问题了，IPv4 如何迁移到 IPv6 呢？这就是我们接下来讨论的重点。</p><h3 id="标志"><span class="mr-2"><strong>标志</strong></span><a href="#标志" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>最简单的方式就是设置一个标志日，指定某个时间点和日期，此时全球的因特网机器都会在这时关机从 IPv4 迁移到 IPv6 。上一次重大的技术迁移是在 35 年前，但是很显然，不用我过多解释，这种情况肯定是 不行的。影响不可估量不说，如何保证全球人类都能知道如何设置自己的 IPv6 地址？一个设计数十亿台机器的标志日现在是想都不敢想的。</p><h3 id="隧道技术"><span class="mr-2"><strong>隧道技术</strong></span><a href="#隧道技术" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>现在已经在实践中使用的从 IPv4 迁移到 IPv6 的方法是 隧道技术(tunneling)。</p><p>什么是隧道技术呢？</p><p>隧道技术是一种<strong>使用互联网络的基础设施在网络之间的传输数据的方式</strong>，使用隧道传递的数据可以是不同协议的数据帧或包。使用隧道技术所遵从的协议叫做隧道协议(tunneling protocol)。隧道协议会将这些协议的数据帧或包封装在新的包头中发送。新的包头提供了路由信息，从而使封装的负载数据能够通过互联网络进行传递。</p><p>使用隧道技术一般都会建一个隧道，建隧道的依据如下：</p><p>比如两个 IPv6 节点(下方 B、E)要使用 IPv6 数据报进行交互，但是它们是经由两个 IPv4 的路由器进行互联的。那么我们就需要将 IPv6 节点和 IPv4 路由器组成一个隧道，如下图所示</p><p><a href="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121170236361.png" class="popup img-link "><img data-src="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121170236361.png" alt="image-20240121170236361" class="lazyload" data-proofer-ignore></a></p><p>借助于隧道，在隧道发送端的 IPv6 节点可将整个 IPv6 数据报放到一个 IPv4 数据报的数据(有效载荷) 字段中，于是，IPv4 数据报的地址被设置为指向隧道接收端的 IPv6 的节点，比如上面的 E 节点。然后再发送给隧道中的第一个节点 C，如下所示</p><p><a href="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121170342220.png" class="popup img-link "><img data-src="/assets/blog_res/2024-01-07-NetWorkLayerTwo.assets/image-20240121170342220.png" alt="image-20240121170342220" class="lazyload" data-proofer-ignore></a></p><p>隧道中间的 IPv4 提供路由，路由器不知道这个 IPv4 内部包含一个指向 IPv6 的地址。隧道接收端的 IPv6 节点收到 IPv4 数据报，会确定这个 IPv4 数据报含有一个 IPv6 数据报，通过观察数据报长度和数据得知。然后取出 IPv6 数据报，再为 IPv6 提供路由，就好像两个节点直接相连传输数据报一样。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/'>计算机网络</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E5%AD%A6%E4%B9%A0/" class="post-tag no-text-decoration" >学习</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82(%E4%BA%8C)%20-%20YKFire&url=%2Fposts%2FNetWorkLayerTwo%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82(%E4%BA%8C)%20-%20YKFire&u=%2Fposts%2FNetWorkLayerTwo%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FNetWorkLayerTwo%2F&text=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82(%E4%BA%8C)%20-%20YKFire" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/ApplyProtocol2/">计算机网络应用层协议(二)</a><li><a href="/posts/ApplyProtocol/">计算机网络应用层协议(一)</a><li><a href="/posts/NetworkOne/">计算机网络发展史(一)</a><li><a href="/posts/NetworkTwo/">计算机网络发展史(二)</a><li><a href="/posts/NetworkThree/">计算机网络发展史(三)</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a> <a class="post-tag" href="/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/">职业规划</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/surroundedByAlgorithms/"><div class="card-body"> <em class="small" data-ts="1700983740" data-df="YYYY/MM/DD" > 2023/11/26 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>完蛋！我被算法包围了</h3><div class="text-muted small"><p> 算法在日常生活的应用 算法听上去很复杂，离我们很遥远。但是以下 10 种算法广泛用于我们的日常生活，包括互联网搜索引擎、社交网络、WiFi、手机甚至卫星。 以下是主宰我们世界的十种算法： 01 排序 我们学习算法一般都是从排序算法开始的，比如冒泡排序、快排序、归并排序、堆排序等。 笔者曾经做过的一个大批量对账系统，就是在第一步使用归并外排序（External MergeSort...</p></div></div></a></div><div class="card"> <a href="/posts/MyFirstBlog/"><div class="card-body"> <em class="small" data-ts="1662124620" data-df="YYYY/MM/DD" > 2022/09/02 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>我的第一篇博客！</h3><div class="text-muted small"><p> 我的第一篇博客！ 这里可以放代码片段噢～ //代码片段 int main(){ hello world; }</p></div></div></a></div><div class="card"> <a href="/posts/List/"><div class="card-body"> <em class="small" data-ts="1662694200" data-df="YYYY/MM/DD" > 2022/09/09 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>数据结构--链表</h3><div class="text-muted small"><p> 数据结构–链表 一、链表简介 什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域，一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思） 链接的入口节点称为链表的头结点也就是head 链表的两种操作方法：①直接使用原来的链表进行操作 ②设置一个虚拟头结点进行操作 一般设置一个虚拟头结点来操作...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/NetWorkLayerOne/" class="btn btn-outline-primary" prompt="上一篇"><p>计算机网络网络层(一)</p></a> <a href="/posts/TCP&UDP/" class="btn btn-outline-primary" prompt="下一篇"><p>详解 TCP 和 UDP 的区别</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a> <a class="post-tag" href="/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/">职业规划</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/username">YKFire</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
