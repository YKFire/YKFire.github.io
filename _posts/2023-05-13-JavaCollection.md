---
title: Java集合详解
date: 2023-05-13 19:31:00 +0800
categories: [随笔]
tags: [学习]
pin: true
author: YKFire

toc: true
comments: true

math: false
mermaid: true

typora-root-url: ../../YKFire.github.io

---

> 最近重新复习了Java基础，把集合模块的知识好好地整理一遍，本文为笔者复习时的笔记

集合类存放于java.util包中，主要有三种：set、list(列表中包含Queue、stack)、map

![Java集合](/assets/blog_res/2023-05-13-JavaCollection.assets/image-20230515193749783.png)

## 一、List、Set、Map三种集合的特点与区别

### 1、特点

1. List（列表）：

- - 特点：List是一个有序的集合，允许元素重复。它维护了元素的插入顺序，并且可以根据索引访问和操作元素。
  - 适用场景：当需要按照插入顺序存储元素，并且允许重复元素时，可以选择List。常用的List实现类有ArrayList和LinkedList。
  - 线程安全的类有：CopyOnWriteArrayList

2. Set（集合）：

- - 特点：Set是一个不允许重复元素的集合，每个元素在Set中是唯一的。Set不保证元素的顺序，即插入顺序不被保留。
  - 适用场景：当需要存储一组唯一的元素，并且不关心元素的顺序时，可以选择Set。常用的Set实现类有HashSet、TreeSet和LinkedHashSet。
  - 线程安全的类有：CopyOnWriteArraySet、ConcurrentSkipListSet、**ConcurrentHashMap的键的集合视图，即keySet()方法返回的Set集合**

3. Map（映射）：

- - 特点：Map是一种键值对（Key-Value）的集合，每个键是唯一的。可以通过键快速查找、插入和删除与之关联的值。
  - 适用场景：当需要按照键值对的方式存储和检索数据时，可以选择Map。常用的Map实现类有HashMap、TreeMap和LinkedHashMap。
  - 线程安全的类有： ConcurrentHashMap

### 2、区别

- List和Set都是集合，但List允许元素重复，而Set不允许重复元素。
- **List和Set都继承自Collection接口**，而**Map则是独立的接口**。
- List和Set都维护了元素的顺序，可以根据索引（List）或迭代顺序（Set）访问元素，而Map则是通过键来访问值。
- List使用有序的索引来操作元素，支持重复元素，适合需要按顺序存储和访问元素的场景。Set不保证元素的顺序，并且不允许重复元素，适合需要存储唯一元素的场景。Map通过键值对存储数据，可以根据键快速查找和操作对应的值，适合需要根据键检索数据的场景。



## 二、Set集合怎么去重

Set集合是自动去重的，即不允许包含重复的元素。当向Set集合中添加元素时，如果元素已经存在于集合中，那么添加操作将不会生效，集合中仍然保持原有的唯一性。

### **是如何实现的?原理是什么？**

Set集合实现去重的原理是基于元素的唯一性。当向Set集合中添加元素时，集合会根据元素的**哈希值（hashCode）和相等性（equals）**来判断是否已经存在相同的元素。

具体实现的步骤如下：

1. 当向Set集合中添加元素时，集合会首先调用元素的**hashCode()**方法获取元素的哈希值。
2. Set集合内部使用**哈希表（Hash Table）或平衡二叉树（如红黑树）**来存储元素。
3. 首先，Set集合会根据元素的哈希值，将元素放入合适的桶（bucket）或树节点中。
4. 如果桶或树节点为空，直接将元素存入其中；如果不为空，则进行相等性判断。
5. 集合会调用元素的**equals()**方法来比较新元素和已存在的元素是否相等。
6. 如果**equals()**方法返回**true**，表示新元素和已存在的元素相等，则新元素不会被添加到集合中；如果返回**false**，则将新元素添加到集合中。

通过使用哈希值和相等性的判断，Set集合可以保证其中的元素是唯一的。这种实现方式可以高效地进行去重操作，并且不需要手动进行遍历和比较元素。因此，Set集合是一种非常方便的数据结构，适用于存储唯一元素的场景。

> 面试时这里可能就会涉及hashcode与equals的区别



## 三、hashset与treeset如何去重和排序

HashSet和TreeSet在去重和排序方面有一些不同的特点。

HashSet：

- 去重：HashSet通过元素的**哈希值来确定元素的存储位置**，当向HashSet中添加元素时，先计算元素的哈希值，然后将元素放入相应的哈希桶中。如果新元素的哈希值与已存在的元素的哈希值相同，HashSet会**调用元素的equals()**方法进行相等性比较，如果返回true，则认为元素已存在，不会被添加到集合中。
- 排序：HashSet不会对元素进行排序，元素在HashSet中的存储顺序由哈希值决定，不保证插入顺序或其他特定的顺序。

TreeSet：

- 去重：TreeSet通过比**较元素的大小来确定元素的存储位置**。当向TreeSet中添加元素时，TreeSet会调用**元素的compareTo()**方法或自定义的比较器来确定元素的顺序**。如果新元素与已存在的元素相等，TreeSet会认为新元素是重复的，不会被添加到集合中。
- 排序：TreeSet会对元素进行排序，元素按照**自然顺序或自定义比较器定义的顺序进行排序**。在添加元素时，TreeSet会根据元素的比较结果将元素放入合适的位置，从而实现了排序。

总结：

- HashSet通过**哈希值和相等性来去重，不进行排序。**
- TreeSet通过**比较元素的大小来去重，并且会对元素进行排序。**

因此，如果只需要去重功能而不关心元素的顺序，可以选择HashSet。**如果需要去重并且希望元素按照一定的顺序进行存储和遍历，可以选择TreeSet**，并根据需要实现**Comparable**接口或传入自定义的比较器。

> 自定义排序：实现**Comparable**接口或传入自定义的比较器



## 四、如何实现set集合的有序性？

如果需要实现有序的Set集合，可以**使用TreeSet类**。TreeSet是基于红黑树（红黑二叉搜索树）实现的Set集合，它可以按照元素的自然顺序或自定义的比较器来进行排序。

> 面试的时候提redis的zset集合也是一种不错的思路



## 五、集合底层实现

### 1、**List集合**

Java中的List集合有多种实现，每种实现都有不同的底层数据结构。

以下是一些常见的List集合实现及其底层数据结构：

1. ArrayList：

- - 底层数据结构：ArrayList**使用动态数组实现**。它内部使用数组来存储元素，并根据需要动态调整数组的大小。当元素数量超过数组容量时，ArrayList会创建一个更大的数组，并将元素复制到新数组中。

2. LinkedList：

- - 底层数据结构：LinkedList使用**双向链表实现**。它内部的节点包含了元素本身以及指向前一个节点和后一个节点的引用。LinkedList通过节点的链接来实现元素的插入、删除和访问。

3. Vector：

- - 底层数据结构：Vector也使用**动态数组实现**，与ArrayList类似。它是Java早期提供的**线程安全的List集合实现**，但在性能上不如ArrayList。由于其线程安全的特性，现在一般更推荐使用ConcurrentArrayList或**CopyOnWriteArrayList来替代Vecto**r。

4. Stack：

- - 底层数据结构：**Stack是Vector的子类，它基于动态数组实现**。Stack是一种后进先出（LIFO）的数据结构，支持压栈（push）和出栈（pop）操作。

5. CopyOnWriteArrayList：

- - 底层数据结构：CopyOnWriteArrayList也使用**动态数组实现**，类似于ArrayList。但与ArrayList不同的是，CopyOnWriteArrayList在**修改操作时会创建一个新的数组，并将元素复制到新数组中**，从而实现读写分离，**保证了读操作的并发性。**

这些List集合实现使用不同的底层数据结构，每种数据结构都有不同的特点和适用场景。选择合适的List集合实现取决于具体的需求，例如对性能、线程安全性或特定操作的需求。一般情况下，ArrayList是使用最广泛的List集合实现，它提供了快速的随机访问和修改操作。



### 2、**Map集合**

Java中的Map集合也有多种实现，每种实现都有不同的底层数据结构。

以下是一些常见的Map集合实现及其底层数据结构：

1. HashMap：

- - 底层数据结构：HashMap使用**哈希表（散列表）实现**。它通过键的哈希值来确定键值对的存储位置，并**使用链表或红黑树处理键的哈希冲突**。在Java 8及之后的版本，当链表长度超过一定阈值时，会将链表转换为红黑树，以提高查找效率。

2. TreeMap：

- - 底层数据结构：TreeMap使用**红黑树（红黑二叉搜索树）实现**。它根据键的自然顺序或自定义的比较器来**对键进行排序**，并将键值对存储在树节点中。红黑树的特点保证了键值对的有序性。

3. LinkedHashMap：

- - 底层数据结构：LinkedHashMap是HashMap的子类，它使用**哈希表和双向链表实现**。除了哈希表的快速查找特性外，LinkedHashMap还**维护了键值对的插入顺序或访问顺序（可配置）**，通过双向链表来保持顺序。

4. ConcurrentHashMap：

- - 底层数据结构：ConcurrentHashMap是**哈希表的线程安全实现**，内部使用**分段锁（Segment）来实现并发访问**。它在多线程环境下提供了高并发的读操作，并且支持并发的读写操作。

5. Hashtable：

- - 底层数据结构：Hashtable是**早期Java版本提供的线程安全的哈希表实现，与HashMap类似**。不同之处在于Hashtable的操作是同步的，保证了线程安全，但也导致了性能上的一些损耗。现在一般**更推荐使用ConcurrentHashMap来替代Hashtable。**

这些Map集合实现使用不同的底层数据结构，每种数据结构都有不同的特点和适用场景。选择合适的Map集合实现取决于具体的需求，例如对性能、线程安全性、有序性或特定操作的需求。一般情况下，HashMap是使用最广泛的Map集合实现，它提供了快速的查找、插入和删除操作。



### 3、**Set集合**

Java中的Set集合也有多种实现，每种实现都有不同的底层数据结构。

以下是一些常见的Set集合实现及其底层数据结构：

1. HashSet：

- - 底层数据结构：HashSet使用**哈希表（散列表）实现**。它通过元素的哈希值来确定元素的存储位置，并**使用链表或红黑树处理哈希冲突**。在Java 8及之后的版本，当链表长度超过一定阈值时，会将链表转换为红黑树，以提高查找效率。

2. TreeSet：

- - 底层数据结构：TreeSet使用**红黑树（红黑二叉搜索树）实现**。它根据元素的自然顺序或自定义的比较器来对元素进行排序，并将元素存储在树节点中。红黑树的特点保证了元素的有序性。

3. LinkedHashSet：

- - 底层数据结构：LinkedHashSet是HashSet的子类，它使用**哈希表和双向链表**实现。除了哈希表的快速查找特性外，LinkedHashSet还维护了元素的插入顺序或访问顺序（可配置），通过双向链表来保持顺序。

4. ConcurrentSkipListSet：

- - 底层数据结构：ConcurrentSkipListSet使用**跳表数据结构实现**。它是一种有序的并发数据结构，支持快速的查找、插入和删除操作，并且支持并发访问。

5. CopyOnWriteArraySet：

- 类型：它是**基于CopyOnWriteArrayList**的线程安全Set集合**实现**。
- 特点：CopyOnWriteArraySet使用**CopyOnWrite机制**，在修改操作时会创建一个新的底层数组，并将元素复制到新数组中。这种机制保证了读操作的并发性，并且不会导致读取操作的异常或修改操作的冲突

这些Set集合实现使用不同的底层数据结构，每种数据结构都有不同的特点和适用场景。选择合适的Set集合实现取决于具体的需求，例如对性能、有序性、并发性或特定操作的需求。一般情况下，HashSet是使用最广泛的Set集合实现，它提供了快速的查找、插入和删除操作。