---
title: 加密算法
date: 2022-12-28 15:00:00 +0800
categories: [技术科普]
tags: [学习]
pin: true
author: YKFire

toc: true
comments: true

math: false
mermaid: true

typora-root-url: ../../YKFire.github.io

---

# 加密算法 

## 一、加密算法的种类

### 1、对称加密

​	加密和解密用的都是同一个秘钥的加密形式，就叫对称加密。

### 2、非对称加密

> 公钥负责加密，私钥负责解密。公钥人人可得，私钥永远不泄露

​	加密和解密用到的不是同一个秘钥，而是两个**不一样的秘钥**，分别是**公钥和私钥**，就叫做非对称加密。

## 二、 为啥不能用公钥解密？

> 说白了**加密**就是将一个已知的数字**根据一定的规则**转换变成另一个数字，以前这些数字放在一起都可读，但是经过这么一转换，就变得不可读了。也就是说加密的本质就是 `num -> x` （num是已知数，x是未知数）
>
> 从数学原理也能看出，公钥和私钥加密是安全的，但这件事情的前提是建立在"现在的计算机计算速度还不够快"这个基础上。因此，如果有一天科技变得更发达了，我们变成了更高维度的科技文明，可能现在的密文就跟明文没啥区别了。

因为大数取模运算是**不可逆的**，因此他人无法暴力解密。但是结合欧拉定理，我们可以选取出合适的p（公钥）, q（私钥）, N（用于取模的大数），让原本不可逆的运算在特定情况下，变得有那么点“可逆”的味道。数学原理决定了我们用公钥加密的数据，只有私钥能解密。反过来，用私钥加密的数据，也只有公钥能解密。

![加密与解密](/assets/blog_res/2022-12-28-Password.assets/image-20221231194626448.png)

## 三、HTTPS的原理

> 了解了对称加密和非对称机密之后，我们就可以聊聊HTTPS的加密原理了

首先是建立TCP连接，毕竟HTTP是基于TCP的应用层协议(TCP三次握手)

在TCP成功建立完协议后，就可以开始进入HTTPS的加密流程。

总的来说。整个加密流程其实分为**两阶段**。

![HTTPS的连接流程](/assets/blog_res/2022-12-28-Password.assets/image-20221231195007645.png)

**第一阶段**是TLS四次握手，这一阶段主要是利用**非对称加密**的特性各种交换信息，最后得到一个"会话秘钥"。

**第二阶段**是则是在第一阶段的"**会话秘钥**"基础上，进行**对称加密**通信。

我们先来看下第一阶段的**TLS四次握手**是怎么样的。

![TLS四次握手](/assets/blog_res/2022-12-28-Password.assets/image-20221231195118565.png)

**第一次握手**：

- `Client Hello`：是客户端告诉服务端，它支持什么样的加密协议版本，比如 `TLS1.2`，使用什么样的加密套件，比如最常见的`RSA`，同时还给出一个**客户端随机数**。

**第二次握手**：

- `Server Hello`：服务端告诉客户端，**服务器随机数** + 服务器证书 + 确定的加密协议版本（比如就是TLS1.2）。

**第三次握手**：

- `Client Key Exchange`: 此时客户端再生成**一个随机数**，叫 `pre_master_key `。从第二次握手的**服务器证书**里取出服务器公钥，用公钥加密 `pre_master_key`，发给服务器。
- `Change Cipher Spec`: 客户端这边**已经拥有三个随机数**： 客户端随机数，服务器随机数和pre_master_key，用这三个随机数进行计算得到一个"**会话秘钥**"。此时客户端通知服务端，后面会用这个会话秘钥进行对称机密通信。
- `Encrypted Handshake Message`：客户端会把迄今为止的通信数据内容生成一个摘要，用"**会话秘钥**"加密一下，发给服务器做校验，此时客户端这边的握手流程就结束了，因此也叫**Finished报文**。

**第四次握手**：

- `Change Cipher Spec`：服务端此时拿到客户端传来的 `pre_master_key`（虽然被服务器公钥加密过，但服务器有私钥，能解密获得原文），集齐三个随机数，跟客户端一样，用这三个随机数通过同样的算法获得一个"**会话秘钥**"。此时服务器告诉客户端，后面会用这个"会话秘钥"进行加密通信。
- `Encrypted Handshake Message`：跟客户端的操作一样，将迄今为止的通信数据内容生成一个摘要，用"**会话秘钥**"加密一下，发给客户端做校验，到这里，服务端的握手流程也结束了，因此这也叫**Finished报文**。

> https都于对称加密与非对称加密两种方式都使用到了，前期4次握手，本质上就是在利用**非对称加密**的特点，交换三个随机数。
>
> 目的就是为了最后用这三个随机数生成**对称加密的"会话秘钥"**。后期就一直用对称机密的方式进行通信。

## 四、服务器证书与CA证书

> HTTPS连接过程中涉及到了两对公钥与秘钥的使用

**服务器本身的公钥和私钥**：在第二次握手中，服务器将自己的**公钥**（藏在数字证书里）发给客户端。第三次握手中用这个服务器**公钥**来加密第三个随机数 `pre_master_key`。服务器拿到后用自己的**私钥**去做解密。

**CA的公钥和私钥**：第二次握手中，传的数字证书里，包含了被**CA的私钥**加密过的服务器公钥。客户端拿到后，会用实现内置在操作系统或浏览器里的**CA公钥**去进行解密。

CA秘钥加密服务器公钥：

![1](/assets/blog_res/2022-12-28-Password.assets/image-20221231195527937.png)

CA公钥解密服务器证书：

![2](/assets/blog_res/2022-12-28-Password.assets/image-20221231195541536.png)

CA公钥内置在操作系统或浏览器里：

![3](/assets/blog_res/2022-12-28-Password.assets/image-20221231195602653.png)