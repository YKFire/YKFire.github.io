<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>YKFire</title><subtitle>这是通过Chirpy主题配置而成的</subtitle> <updated>2024-02-01T13:03:34+00:00</updated> <author> <name>YKFire</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="/"/> <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator> <rights> © 2024 YKFire </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Spring Boot自动装配原理</title><link href="/posts/AutomaticAssembly/" rel="alternate" type="text/html" title="Spring Boot自动装配原理" /><published>2024-01-14T12:17:00+00:00</published> <updated>2024-01-14T12:17:00+00:00</updated> <id>/posts/AutomaticAssembly/</id> <content src="/posts/AutomaticAssembly/" /> <author> <name>YKFire</name> </author> <category term="技术科普" /> <summary> Spring Boot自动装配原理 要理解自动装配，主要是要理解透彻两个配置文件的作用，一个是application.yml，一个是spring.factories。下文，让我们具体来讲讲！ Bean自动装载配置的核心问题 Spring Boot里面的各种Bean(类对象)能够实现自动装载，自动的装载帮我们减少了XML的配置，和手动编码进行Bean的加载工作。从而极大程度上帮我们减少了配置量和代码量。 要实现Bean的自动装载，需要解决两个问题： 如何保证Bean自动装载的灵活性？这个问题通过配置文件来解决，在配置A情况下去装载BeanY；在配置B情况下去装载BeanZ。（通常情况下配置A和B会有默认值，来决定默认的装载行为，这样就不需要我们配置了，进一步减少配置量） 如何保证Bean装载的顺序性？当BeanA装载完成之后再去装载BeanY，BeanY装载完成... </summary> </entry> <entry><title>详解 TCP 和 UDP 的区别</title><link href="/posts/TCP&amp;UDP/" rel="alternate" type="text/html" title="详解 TCP 和 UDP 的区别" /><published>2024-01-14T12:17:00+00:00</published> <updated>2024-01-14T12:17:00+00:00</updated> <id>/posts/TCP&amp;UDP/</id> <content src="/posts/TCP&amp;UDP/" /> <author> <name>YKFire</name> </author> <category term="计算机网络" /> <summary> 详解 TCP 和 UDP 的区别 TCP 和 UDP 的区别一直是面试的重点，也是经常被用来拿来各种比较的两个协议。 建立连接的差异 TCP 建立连接需要经过三次握手，同时 TCP 断开连接需要经过四次挥手，这也表示 TCP 是一种面向连接的协议，这个连接不是用一条网线或者一个管道把两个通信双方绑在一起，而是建立一条虚拟通信管道。 TCP 的三次握手流程（客户端向服务器发送建立连接请求）： 服务端进程准备好接收来自外部的 TCP 连接，一般情况下是调用 bind、listen、socket 三个函数完成。这种打开方式被认为是 被动打开(passive open)。然后服务端进程处于 LISTEN 状态，等待客户端连接请求。 客户端通过 connect 发起主动打开(active open)，向服务器发出连接请求，请求中首部同步位 SYN = 1，同时选择一个初... </summary> </entry> <entry><title>计算机网络网络层(二)</title><link href="/posts/NetWorkLayerTwo/" rel="alternate" type="text/html" title="计算机网络网络层(二)" /><published>2024-01-07T07:51:00+00:00</published> <updated>2024-01-07T07:51:00+00:00</updated> <id>/posts/NetWorkLayerTwo/</id> <content src="/posts/NetWorkLayerTwo/" /> <author> <name>YKFire</name> </author> <category term="计算机网络" /> <summary> 计算机网络网络层 这是计算机网络之网络层的第二篇文章。 IP 协议 路由器对分组进行转发后，就会把数据传到网络上，数据包最终是要传递到客户端或者服务器上的，那么数据包怎么知道要发往哪里呢？起到关键作用的就是 IP 协议。 IP 主要分为三个部分，分别是 IP 寻址、路由和分包组包。下面我们主要围绕这三点进行阐述。 IP 地址 既然一个数据包要在网络上传输，那么肯定需要知道这个数据包到底发往哪里，也就是说需要一个目标地址信息，IP 地址就是连接网络中的所有主机进行通信的目标地址。因此在网络上的每个主机都需要有自己的 IP 地址。 在 IP 数据包发送的链路中，有可能链路非常长，比如说由中国发往美国的一个数据包，由于网络抖动等一些意外因素可能会导致数据包丢失，这时我们在这条链路中会放入一些中转站，一方面能够判断数据包是否丢失，另一方面能够控制数据包的转发，这个中转站就是... </summary> </entry> <entry><title>计算机网络网络层(一)</title><link href="/posts/NetWorkLayerOne/" rel="alternate" type="text/html" title="计算机网络网络层(一)" /><published>2023-12-31T04:32:00+00:00</published> <updated>2023-12-31T04:32:00+00:00</updated> <id>/posts/NetWorkLayerOne/</id> <content src="/posts/NetWorkLayerOne/" /> <author> <name>YKFire</name> </author> <category term="计算机网络" /> <summary> 计算机网络网络层 前面我们学习了运输层如何为客户端和服务器输送数据的，提供进程端到端的通信。那么下面我们将学习网络层实际上是怎样实现主机到主机的通信服务的。几乎每个端系统都有网络层这一部分。所以，网络层必然是很重要的。下面我将花费大量篇幅来介绍一下计算机网络层的知识。 网络层概述 网络层是 OSI 参考模型的第三层，它位于传输层和链路层之间，网络层的主要目的是实现两个端系统之间透明的数据传输。 网络层的作用从表面看上去非常简单，即将分组从一台主机移动到另外一台主机。为了实现这个功能，网络层需要两种功能 转发：因为在互联网中有很多路由器，这些路由器是构成互联网的基石，为什么这么说呢？因为路由器最重要的一个功能就是分组转发，就是靠着这些路由器，才会把一个个数据包通过链路传输给其他节点。当一个分组到达某路由器的一条输入链路时，该路由器会将分组移动到适当的输出链路。 ... </summary> </entry> <entry><title>评论功能前后端实现方案总结</title><link href="/posts/CommentingSystem/" rel="alternate" type="text/html" title="评论功能前后端实现方案总结" /><published>2023-12-17T11:15:00+00:00</published> <updated>2023-12-17T11:15:00+00:00</updated> <id>/posts/CommentingSystem/</id> <content src="/posts/CommentingSystem/" /> <author> <name>YKFire</name> </author> <category term="技术科普" /> <summary> 评论功能 本文主要就前后端嵌套评论功能的实现方案进行总结和讨论。主要包括前端显示的两种方式、后端评论数据的两种存储方式。 类似: 前端 1. 两种方案 不同角色看到评论类别的操作是由不同的，比如，本人发布的评论我们可以对其进行编辑和修改，且逻辑上不能举报自己，所以在同一页面实现不同显示，我们就需要状态量去控制不同页面元素的显隐。 在此，有两种方案： 由前端设置状态量，并通过后端的数据特征维护这些状态量，判断结束后，前端就能实现不同情况的合理显示。这种方案就是后端省事，前端需要自己做相当一部分事情去判断，要麻烦一些。 数据驱动，传入嵌套评论结构，给页面渲染。即后端在返回前端评论信息时，将这些状态量一并返回。这种的好处就是前后端都相对方便，前端专注于状态量判断和显示，后端专注于状态量的维护，在后端维护是方便的，因为数据就是从此返回的。 2. 方案对比和总结... </summary> </entry> </feed>
