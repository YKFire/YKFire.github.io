---
title: 动态规划详解
date: 2022-10-02 13:04:00 +0800
categories: [数据结构与算法]
tags: [学习]
pin: true
author: YKFire

toc: true
comments: true

math: false
mermaid: true

typora-root-url: ../../YKFire.github.io

---

# 动态规划详解 

## 一、问题引入

​		先来看看生活中经常遇到的事吧——假设您是个土豪，身上带了足够的1、5、10、20、50、100元面值的钞票。现在您的目标是凑出某个金额w，**需要用到尽量少的钞票。**

　　依据生活经验，我们显然可以采取这样的策略：能用100的就尽量用100的，否则尽量用50的……依次类推。在这种策略下，666=6×100+1×50+1×10+1×5+1×1，共使用了10张钞票。

　　这种策略称为“**贪心**”：假设我们面对的局面是“需要凑出w”，**贪心策略会尽快让w变得更小**。能让w少100就尽量让它少100，这样我们接下来面对的局面就是凑出w-100。长期的生活经验表明，贪心策略是正确的。

　　但是，如果我们换一组钞票的面值，贪心策略就也许不成立了。如果一个奇葩国家的钞票面额分别是1、5、11，那么我们在凑出15的时候，贪心策略会出错：
　　15=1×11+4×1    （贪心策略使用了5张钞票）
　　15=3×5               （正确的策略，只用3张钞票）
　　为什么会这样呢？贪心策略错在了哪里？

**鼠目寸光
　　刚刚已经说过，贪心策略的纲领是：“尽量使接下来面对的w更小”。这样，贪心策略在w=15的局面时，会优先使用11来把w降到4；但是在这个问题中，凑出4的代价是很高的，必须使用4×1。如果使用了5，w会降为10，虽然没有4那么小，但是凑出10只需要两张5元。
　　在这里我们发现，贪心是一种**只考虑眼前情况**的策略。

　　那么，现在我们怎样才能避免鼠目寸光呢？

　　如果直接暴力枚举凑出w的方案，明显复杂度过高。太多种方法可以凑出w了，枚举它们的时间是不可承受的。我们现在来尝试找一下性质。

　　重新分析刚刚的例子。w=15时，我们如果取11，接下来就面对w=4的情况；如果取5，则接下来面对w=10的情况。我们发现这些问题都有相同的形式：“给定w，凑出w所用的最少钞票是多少张？”接下来，我们用f(n)来表示“凑出n所需的最少钞票数量”。

　　那么，如果我们取了11，最后的代价（用掉的钞票总数）是多少呢？
　　明显**cost = f(4) + 1 = 4 + 1 = 5**，它的意义是：利用11来凑出15，付出的代价等于f(4)加上自己这一张钞票。现在我们暂时不管f(4)怎么求出来。
　　依次类推，马上可以知道：如果我们用5来凑出15，cost就是 **f(10) + 1 = 2 + 1 = 3** 。

　　那么，现在w=15的时候，我们该取那种钞票呢？**当然是各种方案中，cost值最低的那一个**！

> - 取11:   cost = f(4) + 1 = 4 + 1 = 5
> - 取5:   cost = f(10) + 1 = 2 + 1 = 3
> - 取1:   cost = f(14) + 1 = 4 + 1 = 5

​		显而易见，cost值最低的是取5的方案。**我们通过上面三个式子，做出了正确的决策**！

　　这给了我们一个**至关重要**的启示——**f(n)  只与  f(n-1),f(n-5),f(n-11) 相关**，更准确地说

>    f(n) = min{ f(n-1) ,f(n-5), f(n-11) } + 1

​		这个式子是非常激动人心的。我们要求出f(n)，只需要求出几个更小的f值；既然如此，我们从小到大把所有的f(i)求出来不就好了？注意一下边界情况即可。

**总结原理**

​		我们已 O(n) 的复杂度解决了这个问题，现在回过头来总结：

>- f(n)  只与  f(n-1),f(n-5),f(n-11) 的值相关
>- 我们只关心 f(w) 的值，不关心是怎么凑出来的

​		它与暴力的区别在哪里？我们的暴力枚举了“使用的硬币”，然而这属于冗余信息。我们要的是答案，根本不关心这个答案是怎么凑出来的。譬如，要求出f(15)，只需要知道f(14),f(10),f(4)的值。**其他信息并不需要。**我们舍弃了冗余信息。我们只记录了对解决问题有帮助的信息——f(n).

　　我们能这样干，取决于问题的性质：求出f(n)，只需要知道几个更小的f(c)。**我们将求解f(c)称作求解f(n)的“子问题”。**

　　**这就是DP**（动态规划，dynamic programming）.

　　**将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解**。

## 二、相关概念

### 1、无后效性

> 一旦f(n)确定，“我们如何凑出f(n)”就再也用不着了。
>
> 要求出f(15)，只需要知道f(14),f(10),f(4)的值，而f(14),f(10),f(4)是如何算出来的，对之后的问题没有影响。
>
> **“未来与过去无关”，**这就是**无后效性**。
>
> （严格定义：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。）

### 2、最优子结构

>回顾我们对f(n)的定义：我们记“凑出n所需的**最少**钞票数量”为f(n).
>
>​		f(n)的定义就已经蕴含了“最优”。利用w=14,10,4的**最优**解，我们即可算出w=15的**最优**解。
>
>​		大问题的**最优解**可以由小问题的**最优解**推出，这个性质叫做“最优子结构性质"。
>
>引入这两个概念之后，我们如何判断一个问题能否使用DP解决呢？
>
>　　**能将大问题拆成几个小问题，且满足无后效性、最优子结构性质**。

## 三、DP的应用

### **最长回文子串**

> 给你一个字符串 `s`，找到 `s` 中最长的回文子串
>
> - `1 <= s.length <= 1000`
> - `s` 仅由数字和英文字母组成

![最长回文子串](/assets/blog_res/2022-10-02-DP.assets/image-20221003144216490.png)

解题思路：

​		首先要了解回文串的定义：**是一种特殊的字符串，从左往右读和从右往左读是一样的**，本题的要求则是找出给定字符串中最长的回文串。

​		采用动态规划的方法进行求解，动态规划的本质就是：**能将大问题拆成几个小问题，且满足无后效性、最优子结构性质**，且分别求解这些子问题，即可以推断出大问题的解。在本题中，当回文子串的长度大于2时，那么将它首尾的两个字母去除之后，它仍然是个回文串。即我们可以得出：**当一个子串的长度大于2时，它本身是否为回文串，取决于它去掉首位字符后的子串是否为回文串**。

​		我们用 *dp(i,j)* 表示字符串s的i到j个字母组成的串是否为回文串,Si表示字符串的第i个字符：

>  *dp(i,j)*  =  true  如果子串Si...Sj是回文串
>
>  *dp(i,j)*  =  false  其他情况( 包括①*dp(i,j)* 本身不是一个回文串，②i>j,此时*dp(i,j)* 本身不合法 )

那么此时我们就可以写出本题的动态规划转移方程：

>   *dp(i,j)*  = (Si == Sj)  and   *dp(i+1,j-1)*

上文的所有讨论是建立在子串长度大于 2 的前提之上的，我们还需要考虑动态规划中的边界条件，即子串的长度为 1 或 2，给出边界条件下的动态规划转移方程：

>  *dp(i,i)* = true      			长度为1，它显示回文串
>
>  *dp(i,i+1)* = (Si == Si+1) 	  长度为2，只需要它的两个字符相同，它就是一个回文串

根据这个思路，我们就可以完成动态规划了，最终的答案即为所有*dp(i,j)*= true 中 **j-1+1**（即子串长度）的最大值。

注意：在状态转移方程中，我们是从长度较短的字符串向长度较长的字符串进行转移的，因此一定要注意动态规划的循环顺序。

<img src="/assets/blog_res/2022-10-02-DP.assets/image-20221003152922688.png" alt="存储子串是否为回文串的二维数组" style="zoom:67%;" />

代码实现：

```java
class Solution {
    public String longestPalindrome(String s) {
        //获取字符串的长度
        int len = s.length();
        //判断当字符串长度等于1或0的情况
        if(len < 2){
            return s;
        }
        int maxLen = 1; //回文子串的最长度 初始化为1
        int begin = 0; //回文子串的初始下标
        //创建一个二维数组用于记录是否为回文串
        boolean[][] dp = new boolean[len][len];
        //初始化:所有长度为1的子串都是回文串,即对角线上的元素都为true
        for(int i = 0; i < len; ++i){
            dp[i][i] = true;
        }
        //将字符串对象中的字符转换为一个字符数组
        char[] charArray = s.toCharArray();
        //递推开始,先枚举子串的长度
        for(int L = 2; L <= len; ++L){
            //枚举左边界,左边界的上限可以设置的宽松一点
            for(int i = 0; i < len; i++){
                //可以由 L 和 i 来确定右边界, j - i + 1 = L 得
                int j = L + i - 1;
                //如何j超出字符串数组的长度,则跳出该循环
                if(j >= len){
                    break;
                }
                //进行判断,左右边界的值是否相等
                if(charArray[i] != charArray[j]){//不相等的情况
                    dp[i][j] = false;
                }
                else{//相等的情况
                    if(L == 2){//回文串长度为2的情况，即L == 2
                        dp[i][j] = true;
                    }
                    else{//其他情况
                        dp[i][j] = dp[i+1][j-1];
                    }
                }
                //只要dp[i][L] == true 成立,就表示子串s[i...L]是回文，此时记录回文长度和起始位置
                if(dp[i][j] && j - i + 1 > maxLen){
                    //重新更新maLen和begin的值
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin,begin+maxLen);//截取字符串
    }
}
```

