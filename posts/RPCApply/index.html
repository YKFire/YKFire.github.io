<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="如何设计一个RPC框架?" /><meta name="author" content="YKFire" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="如何设计一个RPC框架？ 本文将通过面试一问一答的形式，来讲解如何设计一个高可用、高性能的RPC框架！" /><meta property="og:description" content="如何设计一个RPC框架？ 本文将通过面试一问一答的形式，来讲解如何设计一个高可用、高性能的RPC框架！" /><link rel="canonical" href="/posts/RPCApply/" /><meta property="og:url" content="/posts/RPCApply/" /><meta property="og:site_name" content="YKFire" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-10-15T06:50:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="如何设计一个RPC框架?" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@YKFire" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"YKFire"},"dateModified":"2023-10-15T06:50:00+00:00","datePublished":"2023-10-15T06:50:00+00:00","description":"如何设计一个RPC框架？ 本文将通过面试一问一答的形式，来讲解如何设计一个高可用、高性能的RPC框架！","headline":"如何设计一个RPC框架?","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/RPCApply/"},"url":"/posts/RPCApply/"}</script><title>如何设计一个RPC框架? | YKFire</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="YKFire"><meta name="application-name" content="YKFire"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/z1.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">YKFire</a></div><div class="site-subtitle font-italic">怕什么真理无穷，进一寸，有一寸的欢喜.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/YKFire" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['1183491613','qq.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>如何设计一个RPC框架?</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>如何设计一个RPC框架?</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1697352600" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2023/10/15 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href=""></a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="8076 字"> <em>44 分钟</em>阅读</span></div></div></div><div class="post-content"><blockquote><p>如何设计一个RPC框架？ 本文将通过面试一问一答的形式，来讲解如何设计一个高可用、高性能的RPC框架！</p></blockquote><h2 id="rpc-模拟面试"><span class="mr-2"><strong>RPC 模拟面试</strong></span><a href="#rpc-模拟面试" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>此处省略一番自我介绍和寒暄，面试官开始夺命十八连问～</p></blockquote><p>👨‍💼 <strong>面试官</strong>：小Y同学，你先说说你的 RPC 项目是怎么实现的？</p><p>👦 <strong>小Y</strong>：（竟然一上来就问这么硬的，还好我早有准备）</p><p>👦 <strong>小Y</strong>：我先给您说说我这个 RPC 项目的核心原理和组件吧，请看这张图：</p><p><a href="/assets/blog_res/2023-10-15-RPCApply.assets/image-20231029145338419.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-15-RPCApply.assets/image-20231029145338419.png" alt="image-20231029145338419" class="lazyload" data-proofer-ignore></a></p><p>RPC 全称为 Remote Procedure Call，意思为远程调用，并且这个过程就像调用本地方法一样简单！我们不需要关注底层的网络传输细节，只需要按照调用本地方法的流程去调用远程方法即可。</p><p>通常，一个 RPC 框架有这么几个核心组件：</p><ol><li>Server<li>Client<li>Server Stub<li>Client Stub</ol><p>Server 和 Client 比较简单，就是常规意义的服务端和客户端，而在 RPC 中，又引入了一个新的概念 「Stub」。</p><p>它起到的作用其实就是代理，处理一些琐碎的事情：</p><ol><li>对于 Client Stub，它主要是将客户端的请求参数、请求服务地址、请求服务名称做一个封装，并发送给 Server Stub<li>对于 Server Stub，它主要用于接收 Client Stub 发送的数据并解析，去调用 Server 端的本地方法</ol><p>以上就是 RPC 的核心啦 ……</p><p>（面试官突然打断）</p><p>👨‍💼 <strong>面试官</strong>：了解，但这些内容属于比较基础的 RPC，实际应用场景中的 RPC 远不止这么简单，你的 RPC 框架还有其它设计吗？</p><p>👦 <strong>小Y</strong>：（我正准备说呢！😭）</p><p>是这样的，接下来我给您看看我这个 RPC 项目的层次结构吧！（好戏还在后面）</p><p><a href="/assets/blog_res/2023-10-15-RPCApply.assets/image-20231029145449365.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-15-RPCApply.assets/image-20231029145449365.png" alt="image-20231029145449365" class="lazyload" data-proofer-ignore></a></p><p>首先，我讲一讲代理层。它其实对应到我之前提到的：按照调用本地方法的流程去调用远程方法。这一功能就是通过代理层来加以实现。通过使用代理模式，我们可以屏蔽远程方法的调用细节，如：网络连接建立、序列化、发送请求数据、获取返回结果、解析结果等一系列操作。</p><p>对于调用者、框架使用者来说，他们只需要直接调用远程方法即可，复杂的逻辑都封装在 RPC 框架中处理。</p><p>我顺便说一下，除了屏蔽调用细节，代理层的其他优点吧：</p><ol><li>代理层可以扩展目标对象的功能<li>代理层可以与客户端进行解耦，提升系统的可扩展性</ol><p>（又被面试官打断）</p><p>👨‍💼 <strong>面试官</strong>：那你的代理层是如何转发请求的呢？在微服务分布式场景下，是有许多服务的，一个服务也可能对应多个实例，你是如何处理的？</p><p>👦 <strong>小Y</strong>：（这不就是注册中心需要解决的事情吗？简单！）</p><p>这正是我准备说的「注册中心层」。如果只使用代理层的话，是很难处理您所说的这种情况的，因为我们需要考虑如何记录众多的服务的地址信息，并在某个服务上下线时，通知其他服务。若这个时候单纯使用代理层去管理这些琐碎的事情，就会造成代码复杂度、耦合度上升，不易于扩展与维护。</p><p>因此，我在 RPC 框架中抽象出了「注册中心层」，专门用于处理服务注册、服务信息查找、服务上下线通知。</p><p>更具体地来说，负责以下三类事项：</p><ol><li>服务发现：客户端需要订阅注册中心。在需要远程调用时，从注册中心中获取信息，然后进行方法调用<li>服务注册：服务提供者将地址、接口、分组等信息存放在注册中心模块，当服务上线、下线均会通知注册中心<li>服务管理：提供服务的上下线管理、服务配置管理、服务健康检查等功能，以保证服务的可靠性和稳定性</ol><p>就像我图中所画的一般：</p><p><a href="/assets/blog_res/2023-10-15-RPCApply.assets/image-20231029145706289.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-15-RPCApply.assets/image-20231029145706289.png" alt="image-20231029145706289" class="lazyload" data-proofer-ignore></a></p><p>👨‍💼 <strong>面试官</strong>：那你的注册中心具体是如何实现的？你是手写了一个注册中心组件吗？</p><p>👦 <strong>小Y</strong>：（糟了，他不会以为我是手写的吧！我得迂回一下！）</p><p>呃，并没有，因为正如之前所说，这里涉及到了数据存储、事件监听机制、心跳机制等多个复杂的工作，而市面上恰好有满足这些特性的开源组件，考虑到整体项目的进度以及手写的复杂程度，最后我还是选择了开源的解决方案。</p><p>👨‍💼 <strong>面试官</strong>：那你是如何做选择的？换句话说，你之前有仔细了解过这些开源组件吗？</p><p>👦 <strong>小Y</strong>：（就知道会问这个，好在我早有准备～）</p><p>在谈如何选择注册中心之前，请让我先简单介绍一下 CAP 理论哈～因为之后我会根据 CAP 理论选择注册中心！</p><p>CAP 理论是分布式系统中的重中之重！</p><p>敲黑板！注册中心重点来喽！觉得有压力的同学可以先跳过，先接着往后读～</p><p><strong>CAP</strong> 是 <strong>Consistency（一致性）</strong>、<strong>Availability（可用性）</strong>、<strong>Partition Tolerance（分区容错性）</strong> 这三个单词首字母组合。</p><p><strong>一致性（Consistency）</strong> : 所有节点访问同一份最新的数据副本</p><p><strong>可用性（Availability）</strong>: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</p><p><strong>分区容错性（Partition Tolerance）</strong> : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</p><p>CAP 并不是简单的 3 选 2，因为分区容错性是必须实现的。以分区容错性作为前提，在一致性与可用性中做选择。</p><p><a href="/assets/blog_res/2023-10-15-RPCApply.assets/image-20231029145852602.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-15-RPCApply.assets/image-20231029145852602.png" alt="image-20231029145852602" class="lazyload" data-proofer-ignore></a></p><ol><li><strong>Zookeeper</strong><li>Zookeeper 通过 znode 节点来存储数据。因此我们可以利用这一特性进行服务注册，节点用于存储服务 IP、端口、协议等信息。<li>例如：服务提供者上线时，Zookeeper 创建该节点 - /provider/{serviceName}:{ip}:{port}<li>Zookeeper 提供 Watcher 机制，可以监听相应的节点路径。因此我们可以利用这一机制监听对应的路径，一旦路径上的数据发生了变化，我们便向其他订阅该服务的服务发送数据变更消息。收到消息的服务便去更新本地缓存列表。<li>Zookeeper 提供心跳检测功能，定时向各个服务提供者发送心跳请求，确保各个服务存活。如果服务一直未响应，则说明服务挂了，将该节点删除。<li>Zookeeper 遵循一致性原则，即 「CP」<li>对于注册中心而言，最重要的是可用性，我们需要随时能够获取到服务提供者的信息，即使它可能是几分钟以前的旧信息。<li>但是 Zookeeper 由于其核心算法是 ZAB，主要适用于分布式协调系统（分布式配置、集群管理等场景）。当 master 节点故障后，剩余节点会重新进行 leader 选举，导致在选举期间整个 Zookeeper 集群不可用。<li><strong>Nacos</strong><li>服务提供者启动时，会向 Nacos Server 注册当前服务信息，并建立心跳机制，检测服务状态。<li>服务消费者启动时，从 Nacos Server 中读取订阅服务的实例列表，缓存到本地。并开启定时任务，每隔 10s 轮询一次服务列表并更新。<li>Nacos Server 采用 Map 保存实例信息。当配置持久化后，该信息会被保存到数据库中。<li>对于服务健康检查，Nacos 提供了 agent 上报与服务端主动监测两种模式<li>Nacos 支持 CP 和 AP 架构，根据 ephemeral 配置决定<li>ephemeral = true，则为 AP<li>ephemeral = false，则为 CP<li><strong>Eureka</strong><li>服务提供者启动时，会到 Eureka Server 去注册服务<li>服务消费者会从 Eureka Server 中定时以全量或增量的方式获取服务提供者信息，并缓存到本地<li>各个服务会每隔 30s 向 Eureka Server 发送一次心跳请求，确认当前服务正常运行。若 90s 内 Eureka Server 未收到心跳请求，则将对应服务节点剔除。<li>Eureka 遵循可用性原则，即「AP」。<li>Eureka 为「去中心化结构」，没有 master / slave 节点之分。只要还有一个 Eureka 节点存活，就仍然可以保证服务可用。但是可能会出现数据不一致的情况，即查到的信息不是最新的。<li>Eureka 节点收到请求后，会在集群节点间进行复制操作，复制到其他节点中。<li><strong>Consul</strong><li>服务提供者启动时，会向 Consul Server 发送一个 Post 请求，注册当前服务信息<li>服务消费者发起远程调用时，会向 Consul Server 发送一个 Get 请求，获取对应服务的全部节点信息<li>Consul Server 每隔 10s 会向服务提供者发送健康检查请求，确保服务存活，并更新服务节点列表信息。<li>Consul 遵循一致性原则，即「CP」</ol><p>这 4 种开源组件均满足注册中心需求。在这种场景下，技术选型就是一个 Trade-off 了，我们需要选择一个最适合的组件！</p><ol><li>对于 Consul，它底层语言是 Go，更支持容器化场景，而当前 RPC 框架采用的是 Java 语言，所以就先淘汰啦～<li>对于 Eureka，它很适合作为注册中心，但是其维护更新频率很低，目前国内使用的人很少，所以在这里就先不使用啦～<li>对于 Nacos，它是目前国内非常主流的一种注册中心，而且由 Alibaba 开源。<li>最后，我还是选择了 Zookeeper，虽然 Zookeeper 追求一致性导致其不太适合于注册中心场景，但是国内 Dubbo 框架选用了 Zookeeper 作为注册中心，能从 Dubbo 框架中参考到许多优秀的实现技巧。并且，我们可以通过操作 Zookeeper 节点，从更加底层的角度感受如何实现注册服务。</ol><p>（啊～终于说完了，好累）</p><p>👨‍💼 <strong>面试官</strong>：嗯，说的很不错，看来在技术选型上做了很多功课！你最终选用了 Zookeeper，那你还知道 Zookeeper 的其它应用场景吗？</p><p>👦 <strong>小Y</strong>：（竟然问这么细）除了注册中心，Zookeeper 还可以实现分布式锁、分布式 ID、配置中心等功能。</p><p>对于分布式锁：</p><ol><li>Zookeeper 有一种节点为临时节点，它可以保证服务宕机后节点自动被删除，不需要额外考虑添加节点过期时间来解决死锁问题。<li>Zookeeper 可以通过使用顺序节点，满足公平锁特性。<li>Zookeper 节点加锁时，通过监听前驱节点状态，判断是否获取到锁。<li>如果监听到它的前驱节点被删除时，则相当于获取到锁；否则阻塞。</ol><p>对于分布式 ID：</p><ol><li>Zookeeper 可以通过其顺序节点，实现分布式 ID，确保分布式环境下 ID 不重复。</ol><p>对于配置中心：</p><ol><li>通过 znode 节点实现配置存储<li>通过 Watcher 监听节点信息是否发生变化，若发生变化，则通知客户端更新配置信息。</ol><p>👨‍💼 <strong>面试官</strong>：掌握得可以呀～那你接着说吧。</p><p>👦 <strong>小Y</strong>：之前我们有提到，一个服务可能对应着多个实例节点，从注册中心中获取到的可能不止有一个服务地址，可能是一个地址信息 List。这时候我们就需要借助「路由层」，帮助我们从多个实例节点中选取一个，这就是「负载均衡」。在我的 RPC 框架中，我提供了如下 5 种负载均衡策略：</p><ol><li>随机选取策略<li>轮询策略<li>加权轮询策略<li>最少活跃连接策略<li><p>一致性 Hash 策略</p><li>对于「随机选取」策略，顾名思义，即<strong>从多个节点中随机选取一个节点进行访问</strong>。这种方式最大的优点就是简单，但是当请求数量较少时，随机性可能不强，可能会出现单实例节点负载过大的情况。当请求数量很大时，每个实例节点接受的请求数量会接近于均衡，效果较好。<li>对于「轮询」策略，即<strong>轮转调度</strong>。假设当前服务有 3 个实例节点，第一次请求发送给 A 节点，第二次请求发送给 B 节点，第三次请求发送给 C 节点，那么第四次请求就会再次发送给 A 节点，实现均衡请求的效果。<li>对于「加权轮询」策略，是为了解决「轮询」策略所面临的问题。试想一种场景，在当前服务的集群中，有的实例节点配置较高，内存大且多核处理器，那么它就可以承载更多请求。有的实例配置低，那么它的承载能力就会弱一些。这时候「轮询」策略不足以满足这一使用场景。因此，我们需要考虑<strong>为每个实例节点设置权重，使权重大配置高的节点处理更多的请求</strong>，这就是「加权轮询」策略。<li>对于「最少活跃连接」策略，是为了解决以上策略所面临的共同问题。我们再试想一种场景，某些请求的处理时间更长，比如拉取用户粉丝列表，对于头部博主来说，其粉丝数多，拉取时间长，而对于普通用户来说，其粉丝数少，很快就可以拉取完毕。这就导致拉取一个大 V 粉丝列表的时间远长于拉取 100 个普通用户粉丝列表的时间。这时候如果还是按照「轮询」策略，会导致 A 节点即使收到的请求比 B 节点少，但却超过所能承受的最大负载。而「最少活跃连接」策略的意思是<strong>选取当前活跃请求最少的服务节点。</strong>因此，在这种场景下，更适合使用「最少活跃连接」策略，会得到更合理的负载均衡效果。<li>对于「一致性 Hash」策略，是通过请求中携带的参数来定位对应的实例节点。比如，请求参数中携带了用户 ID。用户 ID 为 1 ～ 10 的请求永远对应到 A 节点，用户 ID 为 11 ～ 20 的请求永远对应到 B 节点，依次类推…</ol><p>这就是路由层的核心作用 —— 「负载均衡」啦～</p><p>👨‍💼 <strong>面试官</strong>：我刚才听你提到一致性 Hash 策略，但好像没有提到 Hash，你能在具体说说吗？</p><ol><li>对于「随机选取」策略，顾名思义，即<strong>从多个节点中随机选取一个节点进行访问</strong>。这种方式最大的优点就是简单，但是当请求数量较少时，随机性可能不强，可能会出现单实例节点负载过大的情况。当请求数量很大时，每个实例节点接受的请求数量会接近于均衡，效果较好。<li>对于「轮询」策略，即<strong>轮转调度</strong>。假设当前服务有 3 个实例节点，第一次请求发送给 A 节点，第二次请求发送给 B 节点，第三次请求发送给 C 节点，那么第四次请求就会再次发送给 A 节点，实现均衡请求的效果。<li>对于「加权轮询」策略，是为了解决「轮询」策略所面临的问题。试想一种场景，在当前服务的集群中，有的实例节点配置较高，内存大且多核处理器，那么它就可以承载更多请求。有的实例配置低，那么它的承载能力就会弱一些。这时候「轮询」策略不足以满足这一使用场景。因此，我们需要考虑<strong>为每个实例节点设置权重，使权重大配置高的节点处理更多的请求</strong>，这就是「加权轮询」策略。<li>对于「最少活跃连接」策略，是为了解决以上策略所面临的共同问题。我们再试想一种场景，某些请求的处理时间更长，比如拉取用户粉丝列表，对于头部博主来说，其粉丝数多，拉取时间长，而对于普通用户来说，其粉丝数少，很快就可以拉取完毕。这就导致拉取一个大 V 粉丝列表的时间远长于拉取 100 个普通用户粉丝列表的时间。这时候如果还是按照「轮询」策略，会导致 A 节点即使收到的请求比 B 节点少，但却超过所能承受的最大负载。而「最少活跃连接」策略的意思是<strong>选取当前活跃请求最少的服务节点。</strong>因此，在这种场景下，更适合使用「最少活跃连接」策略，会得到更合理的负载均衡效果。<li>对于「一致性 Hash」策略，是通过请求中携带的参数来定位对应的实例节点。比如，请求参数中携带了用户 ID。用户 ID 为 1 ～ 10 的请求永远对应到 A 节点，用户 ID 为 11 ～ 20 的请求永远对应到 B 节点，依次类推…</ol><p>这就是路由层的核心作用 —— 「负载均衡」啦～</p><p>👨‍💼 <strong>面试官</strong>：我刚才听你提到一致性 Hash 策略，但好像没有提到 Hash，你能在具体说说吗？</p><p>👦 <strong>小Y</strong>：（竟然听的这么细！）好嘞，可能是我漏啦～我们可以从一致性 Hash 环的原理讲起！</p><p><a href="/assets/blog_res/2023-10-15-RPCApply.assets/image-20231029150625601.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-15-RPCApply.assets/image-20231029150625601.png" alt="image-20231029150625601" class="lazyload" data-proofer-ignore></a></p><p>我们可以看到如图「圆环」中存在有 3 个节点，分别为 NodeA / Node B / Node C，4 个请求，分别为 Req 1 / Req 2 / Req 3 / Req 4。</p><p>为什么叫这个「圆环」为「一致性 Hash 环」呢？这是因为我们要对每一个节点根据 Hash 算法计算得到一个 Hash 值，并将其映射到圆环中的某一个位置。对于请求也是如此，根据参数来计算具体的 Hash 值，也映射到圆环中对应的位置。</p><p>接下来的事情就很简单啦，每一个请求沿着当前圆环 <strong>顺时针</strong> 寻找，找到的第一个节点就是对应的处理请求节点。</p><p>如图对应关系为，Node A 处理 Req 3 和 Req 4，Node B 处理 Req 1，Node C 处理 Req 2。</p><p>但是一致性 Hash 环容易造成一个问题，看下面这个图就一目了然啦！</p><p><a href="/assets/blog_res/2023-10-15-RPCApply.assets/image-20231029150755482.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-15-RPCApply.assets/image-20231029150755482.png" alt="image-20231029150755482" class="lazyload" data-proofer-ignore></a></p><p>当服务节点过少时，节点 Hash 值映射到圆环的位置可能聚集于某一处，容易因为节点分布不均匀而造成请求均衡问题，即「数据倾斜」。</p><p>在图中，Node A 承担了大部分请求，Node C 只承担了一个请求，Node B 一个都没有。</p><p>为此，我们需要引入「虚拟节点」解决这一问题。</p><p><a href="/assets/blog_res/2023-10-15-RPCApply.assets/image-20231029150818244.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-15-RPCApply.assets/image-20231029150818244.png" alt="image-20231029150818244" class="lazyload" data-proofer-ignore></a></p><p>图中黄色节点对应的就是「虚拟节点」，起到均衡请求、避免数据倾斜的作用。</p><p>👨‍💼 <strong>面试官</strong>：理解的很到位！你接着说路由层吧～</p><p>👦 <strong>小Y</strong>：（感觉稳了！）路由层除了实现核心的「负载均衡」功能之外，还承担了分配流量的作用。在 RPC 框架中，我们可以将<strong>流量标签、实例标签、路由规则</strong>等信息存储在请求中，这样一来，我们就可以随意控制流量，将请求分配到不同的流量环境。</p><p>基于此，我们可以实现「泳道测试」，即对于生产环境请求，打上对应的 prod 标签，对于测试环境请求，打上对应的 test 标签。这样就可以让大部分请求转发到生产环境服务，而新版本测试请求转发到测试环境服务。</p><p>👨‍💼 <strong>面试官</strong>：时间不多啦，你接着说下一层吧～</p><blockquote><p>关于路由层的知识点，面试一般只会考到「负载均衡」算法。所以为了考虑到大部分读者快速准备面试的需求，对于路由层的高级路由部分，如：条件路由、泳道测试、灰度测试等具体内容，我会放到我的微服务专栏进行详细的讲解～</p></blockquote><p>👦 <strong>小Y</strong>：好嘞！咱们接着说序列化层！由于 RPC 调用的底层是网络请求，当我们的请求携带参数时，请求发送方需要将参数进行「序列化」，从而实现在网络中传输。而请求接收方也需要进行「反序列化」操作，获取到可理解的参数。</p><ol><li>序列化：将数据结构或对象转化为二进制字节流<li>反序列化：将在序列化过程中生成的二进制字节流转化为数据结构或对象</ol><p>为了整合多种序列化框架，我抽象出了序列化层，使用工厂模式，定义了抽象工厂接口，其中有两个方法：serialize 和 deserialize</p><p>并定义相应的序列化实现类，包含如下序列化框架：</p><ol><li>JDK序列化<li>通过ObjectOutputStream的writeObject和readObject方法实现，可通过重写指定其他序列化方式<li>JDK默认序列化方式性能差，且只适用于Java<li>Protocol Buffer<li>支持跨语言、跨平台，可扩展性强<li>需要使用IDL来定义Schema描述文件，定义完描述文件后，可以直接使用protoc来直接生成序列化与反序列化代码<li>性能低于Kyro，但是高于大部分序列化协议，序列化后的size也较小<li>Kyro<li>主要适用于Java，不支持字段扩展<li>使用简洁，直接使用Input、Output对象<li>高性能，序列化与反序列化时间开销都很低，序列化后的size也很小<li>Hessian<li>支持跨语言、跨平台，可扩展性强<li>易用：只需要实现Serializable接口即可<li>序列化时间与大小都比较小</ol><p>👨‍💼 <strong>面试官</strong>：可以的～那在数据传输过程中，可能会出现粘包和半包问题，你是如何解决的？</p><p>👦 <strong>小Y</strong>：（好问题，正好我复习了！）我在做之前，是有了解调研过业界的解决方案，有以下几种：</p><ol><li>固定长度传输：固定好每次数据包的长度，比如规定每次传输长度为 32 个字节。当接收方接满 32 个字节时，代表接受到了完整的信息。<li>该方法灵活性太低<li>特殊字符分割：即每次接收方读取数据时，读到事先约定好的特殊字符时，代表接受到了完整的信息。<li>如果消息内容中刚好有这一特殊字符，需要提前做转义，还是比较麻烦。<li>自定义消息结构</ol><p>最后，考虑到灵活性，决定自定义消息结构，因此我抽象出了「协议层」，专门用于定义消息收发格式。</p><p>自定义协议结构体如下：</p><ol><li>MagicNumber 魔数：用于做安全检测，能够快速确认当前请求是否合法。请求发送方和接收方可以提前约定好魔数。<li>ContentLength 请求长度：协议长度。<li>Content 核心传输数据：封装请求的接收方名称、请求的方法、请求参数等内容<li>这里的 Content 为二进制字节流，对应的就是「序列化层」序列化后得到的二进制字节流。</ol><p>👨‍💼 <strong>面试官</strong>：似乎还有「链路层」和「容错层」，你再展开说说吧～</p><p>👦 <strong>小Y</strong>：好的。我先说说为什么需要「链路层」，其主要用于解决以下两个问题：</p><ol><li>对 RPC 请求做鉴权：请求在到达请求接收方之前，先校验其是否有请求凭证（Token）<li>记录请求过程中的调用日志信息</ol><p>「链路层」的核心设计思想是<strong>责任链设计模式</strong>：</p><ol><li>责任链模式可以使我们任意添加请求的「前处理」和「后处理」对象，并调整处理顺序，提高了维护性和可拓展性，可以根据需求新增处理类，满足开闭原则。<li>责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。<li>责任分担，职责分离。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</ol><p>对于「容错层」，我主要是为了实现服务稳定性治理，确保服务的高可用性。主要通过以下几种手段实现容错层：</p><ol><li>超时重试机制<li>请求一般可以分为「幂等」与「非幂等」请求，幂等性指的是多次请求某一个资源，最后的结果相同，对系统产生的影响相同。<li>在请求重试时，我们需要额外考虑「非幂等请求」重试所带来的风险（比如转账、下单等涉及资金业务场景），当请求超时时，很难判断数据包是否已经到达服务接收方。因此，在请求参数中添加 retry 参数，重试次数由用户自行决定。当 retry = 0 时，则代表请求失败不进行重试。<li>服务限流<li>在高并发场景下，通过限制瞬发 QPS 最大值，从而防止系统被流量击溃，最大限度保证服务高可用。<li>服务熔断<li>在调用过程中，可能出现 Bug、故障等问题。为了防止由于此类问题导致故障在调用链路中扩散，引起「链路雪崩」，我们选择触发「服务熔断」，直接抛出异常，放弃继续调用下游服务，最大程度保护其他服务。</ol><p>👨‍💼 <strong>面试官</strong>：不错，说得很好。但是你的 RPC 框架最后有做压力测试吗？所有框架最后都得使用呀，一定要能投入到生产环境使用。</p><p>👦 <strong>小Y</strong>：（这也要问吗？还好我做了这一步！）您说的没错，我也有考虑到这一点。在写完代码后，我做了一次压力测试：</p><p>我通过设置连续请求次数为 100 / 1000 / 10000，对框架进行压力测试，发现随着请求次数梯度上升，整体接口的响应速度和结果并没有发生变化，说明框架稳定。</p><p>👨‍💼 <strong>面试官</strong>：好的。最后我再问一个问题，你觉得你的 RPC 框架还有什么设计亮眼的地方？</p><p>👦 <strong>小Y</strong>：（啊，终于快要问完了）我在框架中多次运用到了「异步设计」，对各个操作进行解耦。</p><p>对于服务端：</p><ol><li>当请求抵达服务器时，将其直接丢入业务阻塞队列中，然后开辟一个新的线程，从阻塞队列中循环获取Handler请求任务。<li>将获取到的任务对象交付于业务线程池进行消费处理。</ol><p>对于客户端：</p><ol><li>代理层在发送完请求之后，不需要同步阻塞等待响应结果。结果的返回为异步。<li>并且用户可以通过配置文件的方式，自行选择异步或同步。</ol><p>👨‍💼 <strong>面试官</strong>：咦，你提到了你有用线程池技术，那么你是如何选择线程数的呀？</p><p>👦 <strong>小Y</strong>：（什么？不是最后一个问题吗？怎么还有？）</p><p>通用的选择方式是<strong>根据线程池处理任务的类型</strong>进行选择：</p><ol><li>如果是CPU密集型任务，如：加密、解密、压缩、计算，应该根据当前服务器CPU核心数进行选择，最好是CPU核心数的1~2倍<li>如果是IO密集型任务，如：数据库、网络传输、文件读写，应该尽可能提升线程数<li>公式为：线程数 = CPU 核心数 *（1+平均等待时间/平均工作时间）<li>平均等待时间越长，说明是IO密集型，需要增大线程数<li>平均工作时间越长，说明是CPU密集型，需要减少线程数</ol><p>对于我这个框架来说，大部分都是 IO 密集型任务，因此我调大了线程数。</p><p>👨‍💼 <strong>面试官</strong>：好的，可以看出 小Y同学 对于 RPC 设计掌握得确实不错。行吧，回去等通知吧～</p><p>👦 <strong>小Y</strong>：（？？？？？？？？？？？？）</p><h2 id="总结"><span class="mr-2"><strong>总结</strong></span><a href="#总结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>终于写完了，洋洋洒洒将近 1w 字。</p><p>总结一下全文：我们从面试的角度出发，将 RPC 框架拆分了多个层次，逐层剖析 RPC 框架的具体实现原理，也可以帮助大家了解到设计一个RPC框架时应该注意哪些层面的问题。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E6%8A%80%E6%9C%AF%E7%A7%91%E6%99%AE/'>技术科普</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E5%AD%A6%E4%B9%A0/" class="post-tag no-text-decoration" >学习</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AARPC%E6%A1%86%E6%9E%B6?%20-%20YKFire&url=%2Fposts%2FRPCApply%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AARPC%E6%A1%86%E6%9E%B6?%20-%20YKFire&u=%2Fposts%2FRPCApply%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FRPCApply%2F&text=%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AARPC%E6%A1%86%E6%9E%B6?%20-%20YKFire" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/ApplyProtocol2/">计算机网络应用层协议(二)</a><li><a href="/posts/ApplyProtocol/">计算机网络应用层协议(一)</a><li><a href="/posts/NetworkOne/">计算机网络发展史(一)</a><li><a href="/posts/NetworkTwo/">计算机网络发展史(二)</a><li><a href="/posts/NetworkThree/">计算机网络发展史(三)</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a> <a class="post-tag" href="/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/">职业规划</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/NetWorkProtocol5/"><div class="card-body"> <em class="small" data-ts="1700394840" data-df="YYYY/MM/DD" > 2023/11/19 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>计算机网络传输层协议(五)</h3><div class="text-muted small"><p> 传输层协议 这是计算机网络传输层的第五篇文章。 TCP 数据流和窗口管理 我们在之前的讲述中知道了可以使用滑动窗口来实现流量控制，也就是说，客户端和服务器可以相互提供数据流信息的交换，数据流的相关信息主要包括报文段序列号、ACK 号和窗口大小。 图中的两个箭头表示数据流方向，数据流方向也就是 TCP 报文段的传输方向。可以看到，每个 TCP 报文段中都包括了序列号、ACK 和...</p></div></div></a></div><div class="card"> <a href="/posts/MyFirstBlog/"><div class="card-body"> <em class="small" data-ts="1662124620" data-df="YYYY/MM/DD" > 2022/09/02 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>我的第一篇博客！</h3><div class="text-muted small"><p> 我的第一篇博客！ 这里可以放代码片段噢～ //代码片段 int main(){ hello world; }</p></div></div></a></div><div class="card"> <a href="/posts/List/"><div class="card-body"> <em class="small" data-ts="1662694200" data-df="YYYY/MM/DD" > 2022/09/09 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>数据结构--链表</h3><div class="text-muted small"><p> 数据结构–链表 一、链表简介 什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域，一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思） 链接的入口节点称为链表的头结点也就是head 链表的两种操作方法：①直接使用原来的链表进行操作 ②设置一个虚拟头结点进行操作 一般设置一个虚拟头结点来操作...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/ApplyProtocol3/" class="btn btn-outline-primary" prompt="上一篇"><p>计算机网络应用层协议(三)</p></a> <a href="/posts/NetWorkProtocol/" class="btn btn-outline-primary" prompt="下一篇"><p>计算机网络传输层协议(一)</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a> <a class="post-tag" href="/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/">职业规划</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/username">YKFire</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
