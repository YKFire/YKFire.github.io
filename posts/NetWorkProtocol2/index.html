<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="计算机网络传输层协议(二)" /><meta name="author" content="YKFire" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="传输层协议" /><meta property="og:description" content="传输层协议" /><link rel="canonical" href="/posts/NetWorkProtocol2/" /><meta property="og:url" content="/posts/NetWorkProtocol2/" /><meta property="og:site_name" content="YKFire" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-10-29T07:36:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="计算机网络传输层协议(二)" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@YKFire" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"YKFire"},"dateModified":"2023-10-29T07:36:00+00:00","datePublished":"2023-10-29T07:36:00+00:00","description":"传输层协议","headline":"计算机网络传输层协议(二)","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/NetWorkProtocol2/"},"url":"/posts/NetWorkProtocol2/"}</script><title>计算机网络传输层协议(二) | YKFire</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="YKFire"><meta name="application-name" content="YKFire"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/z1.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">YKFire</a></div><div class="site-subtitle font-italic">怕什么真理无穷，进一寸，有一寸的欢喜.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/YKFire" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['1183491613','qq.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>计算机网络传输层协议(二)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>计算机网络传输层协议(二)</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1698564960" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2023/10/29 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href=""></a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6912 字"> <em>38 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="传输层协议"><strong>传输层协议</strong></h1><p>这是计算机网络传输层的第二篇。</p><h2 id="udp"><span class="mr-2"><strong>UDP</strong></span><a href="#udp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>UDP 的全称是<strong>用户数据报协议(UDP，User Datagram Protocol)</strong>，UDP 为应用程序提供了一种无需建立连接就可以封装并发送 IP 数据包的方法。如果应用程序开发人员选择的是 UDP 而不是 TCP 的话，那么该应用程序相当于就是和 IP 直接打交道的。</p><p>从应用程序传递过来的数据，会附加上多路复用/多路分解的源和目的端口号字段，以及其他字段，然后将形成的报文传递给网络层，网络层将运输层报文段封装到 IP 数据报中，再交付给目标主机。</p><h3 id="udp-特点"><span class="mr-2"><strong>UDP 特点</strong></span><a href="#udp-特点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>UDP 协议一般作为流媒体应用、语音交流、视频会议所使用的传输层协议，我们大家都熟知的 DNS 协议底层也使用了 UDP 协议，这些应用或协议之所以选择 UDP 主要是因为以下这几点</p><ol><li><p>速度快，采用 UDP 协议时，只要应用进程将数据传给 UDP，UDP 就会将此数据打包进 UDP 报文段并立刻传递给网络层，然后 TCP 有拥塞控制的功能，它会在发送前判断互联网的拥堵情况，如果互联网极度阻塞，那么就会抑制 TCP 的发送方。使用 UDP 的目的就是希望实时性。</p><li><p>无须建立连接，TCP 在数据传输之前需要经过三次握手的操作，而 UDP 则无须任何准备即可进行数据传输。因此 UDP 没有建立连接的时延。如果使用 TCP 和 UDP 来比喻开发人员：TCP 就是那种凡事都要设计好，没设计不会进行开发的工程师，需要把一切因素考虑在内后再开干！所以非常靠谱；而 UDP 就是那种上来直接干干干，接到项目需求马上就开干，也不管设计，也不管技术选型，就是干，这种开发人员非常不靠谱，但是适合快速迭代开发，因为可以马上上手！</p><li><p>无连接状态，TCP 需要在端系统中维护连接状态，连接状态包括接收和发送缓存、拥塞控制参数以及序号和确认号的参数，在 UDP 中没有这些参数，也没有发送缓存和接受缓存。因此，某些专门用于某种特定应用的服务器当应用程序运行在 UDP 上，一般能支持更多的活跃用户。</p><li><p>分组首部开销小，每个 TCP 报文段都有 20 字节的首部开销，而 UDP 仅仅只有 8 字节的开销。</p></ol><p>这里需要注意一点，并不是所有使用 UDP 协议的应用层都是不可靠的，应用程序可以自己实现可靠的数据传输，通过增加确认和重传机制。所以使用 UDP 协议最大的特点就是速度快。</p><h3 id="udp-报文结构"><span class="mr-2"><strong>UDP 报文结构</strong></span><a href="#udp-报文结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>下面来一起看一下 UDP 的报文结构，每个 UDP 报文分为 UDP 报头和 UDP 数据区两部分。报头由 4 个 16 位长（2 字节）字段组成，分别说明该报文的源端口、目的端口、报文长度和校验值。</p><p><a href="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118154522421.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118154522421.png" alt="image-20231118154522421" class="lazyload" data-proofer-ignore></a></p><ol><li><p>源端口号(Source Port) :这个字段占据 UDP 报文头的前 16 位，通常包含发送数据报的应用程序所使用的 UDP 端口。接收端的应用程序利用这个字段的值作为发送响应的目的地址。这个字段是可选项，有时不会设置源端口号。没有源端口号就默认为 0 ，通常用于不需要返回消息的通信中。</p><li><p>目标端口号(Destination Port): 表示接收端端口，字段长为 16 位。</p><li><p>长度(Length): 该字段占据 16 位，表示 UDP 数据报长度，包含 UDP 报文头和 UDP 数据长度。因为 UDP 报文头长度是 8 个字节，所以这个值最小为 8，最大长度为 65535 字节。</p><li><p>校验和(Checksum)：UDP 使用校验和来保证数据安全性，UDP 的校验和也提供了差错检测功能，差错检测用于校验报文段从源到目标主机的过程中，数据的完整性是否发生了改变。发送方的 UDP 对报文段中的 16 比特字的和进行反码运算，求和时遇到的位溢出都会被忽略，比如下面这个例子，三个 16 比特的数字进行相加</p></ol><p><a href="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118154701200.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118154701200.png" alt="image-20231118154701200" class="lazyload" data-proofer-ignore></a></p><p>这些16比特的前两个和是</p><p><a href="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118154725931.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118154725931.png" alt="image-20231118154725931" class="lazyload" data-proofer-ignore></a></p><p>然后再将上面的结果和第三个 16 比特的数进行相加</p><p><a href="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118154736672.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118154736672.png" alt="image-20231118154736672" class="lazyload" data-proofer-ignore></a></p><p>最后一次相加的位会进行溢出，溢出位 1 要被舍弃，然后进行反码运算，反码运算就是将所有的 1 变为 0 ，0 变为 1。因此 <strong>1000 0100 1001 0101</strong> 的反码就是 <strong>0111 1011 0110 1010</strong>，这就是校验和，如果在接收方，数据没有出现差错，那么全部的 4 个 16 比特的数值进行运算，同时也包括校验和，如果最后结果的值不是 1111 1111 1111 1111 的话，那么就表示传输过程中的数据出现了差错。</p><p>下面来想一个问题，为什么 UDP 会提供差错检测的功能？</p><p>这其实是一种端到端的设计原则，这个原则说的是<strong>要让传输中各种错误发生的概率降低到一个可以接受的水平</strong>。UDP 不可靠的原因是它虽然提供差错检测的功能，但是<strong>对于差错没有恢复能力更不会有重传机制</strong>。</p><h2 id="tcp"><span class="mr-2"><strong>TCP</strong></span><a href="#tcp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>UDP 是一种没有复杂的控制，提供无连接通信服务的一种协议，换句话说，它将部分控制部分交给应用程序去处理，自己只提供作为传输层协议最基本的功能。</p><p>而与 UDP 不同的是，同样作为传输层协议，TCP 协议要比 UDP 的功能多很多。</p><p>TCP 的全称是 Transmission Control Protocol，它被称为是一种面向连接的协议，这是因为一个应用程序开始向另一个应用程序发送数据之前，这两个进程必须先进行握手，握手是一个逻辑连接，并不是两个主机之间进行真实的握手。</p><p><a href="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118154946959.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118154946959.png" alt="image-20231118154946959" class="lazyload" data-proofer-ignore></a></p><p>这个连接是指各种设备、线路或者网络中进行通信的两个应用程序为了相互传递消息而专有的、虚拟的通信链路，也叫做虚拟电路。</p><p>一旦主机 A 和主机 B 建立了连接，那么进行通信的应用程序只使用这个虚拟的通信线路发送和接收数据就可以保证数据的传输，TCP 协议负责控制连接的建立、断开、保持等工作。</p><p>TCP 连接是<strong>全双工服务(full-duplex service)</strong> 的，全双工是什么意思？全双工指的是主机 A 与另外一个主机 B 存在一条 TCP 连接，那么应用程数据就可以从主机 B 流向主机 A 的同时，也从主机 A 流向主机 B。</p><p>一条 TCP 连接只能是<strong>点对点(point-to-point)</strong>的，那么所谓的多播，即一个主机对多个接收方发送消息的情况是不存在的，TCP 连接只能连接两个一对主机。</p><p>一旦 TCP 连接建立后，主机之间就可以相互发送数据了，客户进程通过套接字发送数据。数据一旦通过套接字后，它就由客户中运行的 TCP 协议所控制。</p><p>TCP 会将数据临时存储到连接的<strong>发送缓存(send buffer)</strong>中，这个 send buffer 是三次握手之间设置的缓存之一，然后 TCP 在合适的时间将发送缓存中的数据发送到目标主机的接收缓存中，实际上，每一端都会有发送缓存和接收缓存，如下图所示</p><p><a href="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118155116471.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118155116471.png" alt="image-20231118155116471" class="lazyload" data-proofer-ignore></a></p><p>机之间的发送是以<strong>报文段(segment)</strong>进行的，那么什么是 Segement 呢？</p><p>TCP 会将要传输的数据流分为多个块，然后向每个块中添加 TCP 标头，这样就形成了一个 TCP 段也就是报文段。每一个报文段可以传输的长度是有限的，不能超过<strong>最大数据长度(Maximum Segment Size)</strong>MSS。在报文段向下传输的过程中，会经过链路层，链路层有一个 <strong>Maximum Transmission Unit</strong>，最大传输单元 MTU， 即数据链路层上所能通过最大数据包的大小，最大传输单元通常与通信接口有关。</p><p>因为计算机网络是分层考虑的，这个很重要，不同层的称呼不一样，对于传输层来说，称为报文段而对网络层来说就叫做 IP 数据包，所以，<strong>MTU 可以认为是网络层能够传输的最大 IP 数据包，而 MSS（Maximum segment size）可以认为是传输层的概念，也就是 TCP 数据包每次能够传输的最大量</strong>。</p><h3 id="tcp-报文段结构"><span class="mr-2"><strong>TCP 报文段结构</strong></span><a href="#tcp-报文段结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在简单聊了聊 TCP 连接后，下面我们就来聊一下 TCP 的报文段结构，如下图所示</p><p><a href="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118155301275.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118155301275.png" alt="image-20231118155301275" class="lazyload" data-proofer-ignore></a></p><p>TCP 报文段结构相比 UDP 报文结构多了很多内容。但是前两个 32 比特的字段是一样的。它们是源端口号和目标端口号，我们知道，这两个字段是用于多路复用和多路分解的。另外，和 UDP 一样，TCP 也包含校验和，除此之外，TCP 报文段首部还有下面这些</p><ol><li>32 比特的<strong>序号字段(sequence number field)</strong> 和 32 比特的<strong>确认号字段(acknowledgment number field)</strong>。这些字段被 TCP 发送方和接收方用来实现可靠的数据传输。<li>4 比特的<strong>首部字段长度字段(header length field)</strong>，这个字段指示了以 32 比特的字为单位的 TCP 首部长度。TCP 首部的长度是可变的，但是通常情况下，选项字段为空，所以 TCP 首部字段的长度是 20 字节。<li>16 比特的<strong>接受窗口字段(receive window field)</strong>，这个字段用于流量控制。它用于指示接收方能够/愿意接受的字节数量<li>可变的<strong>选项字段(options field)</strong>，这个字段用于发送方和接收方协商最大报文长度，也就是 MSS 时使用<li>6 比特的<strong>标志字段(flag field)</strong>， ACK 标志用于指示确认字段中的值是有效的，这个报文段包括一个对已被成功接收报文段的确认；RST、SYN、FIN 标志用于连接的建立和关闭；CWR 和 ECE 用于拥塞控制；PSH 标志用于表示立刻将数据交给上层处理；URG 标志用来表示数据中存在需要被上层处理的 <em>紧急</em> 数据。紧急数据最后一个字节由 16 比特的<strong>紧急数据指针字段(urgeent data pointer field)</strong>指出。一般情况下，PSH 和 URG 并没有使用。</ol><p>TCP 的各种功能和特点都是通过 TCP 报文结构来体现的，在聊完 TCP 报文结构之后，我们下面就来聊一下 TCP 有哪些功能及其特点了。</p><h3 id="序号确认号实现传输可靠性"><span class="mr-2"><strong>序号、确认号实现传输可靠性</strong></span><a href="#序号确认号实现传输可靠性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>TCP 报文段首部中两个最重要的字段就是序号和确认号，这两个字段是 TCP 实现可靠性的基础，那么你肯定好奇如何实现可靠性呢？要了解这一点，首先我们得先知道这两个字段里面存了哪些内容吧？</p><p><strong>一个报文段的序号就是数据流的字节编号</strong> 。因为 TCP 会把数据流分割成为一段一段的字节流，因为字节流本身是有序的，所以每一段的字节编号就是标示是哪一段的字节流。比如，主机 A 要给主机 B 发送一条数据。数据经过应用层产生后会有一串数据流，数据流会经过 TCP 分割，分割的依据就是 MSS，假设数据是 10000 字节，MSS 是 2000 字节，那么 TCP 就会把数据拆分成 0 - 1999 , 2000 - 3999 的段，依次类推。</p><p>所以，第一个数据 0 - 1999 的首字节编号就是 0 ，2000 - 3999 的首字节编号就是 2000 。。。。。。</p><p>然后，每个序号都会被填入 TCP 报文段首部的序号字段中。</p><p><a href="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118160012569.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118160012569.png" alt="image-20231118160012569" class="lazyload" data-proofer-ignore></a></p><p>至于确认号的话，会比序号要稍微麻烦一些。这里我们先拓展下几种通信模型。</p><ol><li><p>单工通信：单工通信只支持数据在一个方向上传输；在同一时间只有一方能接受或发送信息，不能实现双向通信，比如广播、电视等。</p><li>双工通信：由两个或者多个发送方同时在两个方向上通信。双工通信模型有两种：<em>全双工(FDX)和半双工(HDX)</em><li>半双工：在半双工系统中，连接双方可以进行通信，但不能同时通信，比如对讲机，只有把按钮按住的人才能够讲话，只有一个人讲完话后另外一个人才能讲话。<li>全双工：在全双工系统中，连接双方可以同时进行通信，一个最常见的例子就是电话通信。全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。</ol><p>单工、半双工、全双工通信如下图所示</p><p><a href="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118160107622.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118160107622.png" alt="image-20231118160107622" class="lazyload" data-proofer-ignore></a></p><p>TCP 是一种全双工的通信协议，因此主机 A 在向主机 B 发送消息的过程中，也在接受来自主机 B 的数据。<strong>主机 A 填充进报文段的确认号是期望从主机 B 收到的下一字节的序号。</strong>稍微有点绕，我们来举个例子看一下。比如主机 A 收到了来自主机 B 发送的编号为 0 - 999 字节的报文段，这个报文段会写入序号中，随后主机 A 期望能够从主机 B 收到 1000 - 剩下的报文段，因此，主机 A 发送到主机 B 的报文段中，它的确认号就是 1000 。</p><h4 id="累积确认"><span class="mr-2"><strong>累积确认</strong></span><a href="#累积确认" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>这里再举出一个例子，比如主机 A 在发送 0 - 999 报文段后，期望能够接受到 1000 之后的报文段，但是主机 B 却给主机 A 发送了一个 1500 之后的报文段，那么主机 A 是否还会继续进行等待呢？</p><p>答案是会的，因为 TCP 只会确认流中至第一个丢失字节为止的字节，因为 1500 虽然属于 1000 之后的字节，但是主机 B 没有给主机 A 发送 1000 - 1499 之间的字节，所以主机 A 会继续等待。</p><p>在了解完序号和确认号之后，我们下面来聊一下 TCP 的发送过程。下面是一个正常的发送过程</p><p><a href="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118164149494.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118164149494.png" alt="image-20231118164149494" class="lazyload" data-proofer-ignore></a></p><p>主机 A 向主机 B 发送了两段报文，第一段报文是 0 - 999 ，主机 B 接收之后会发送确认应答报文，该报文中包含对主机 A 发送 0 - 999 报文段的确认号，应答报文到达主机 A 之后，经过一段时间主机 A 会发送 1000 - 1999 这段报文，主机 B 对其进行确认后再发送应答报文。</p><p>通过上图可以看到，每次主机 A 发送完报文段之后，主机 B 都会发送一个应答报文，主机 A 才会发送接下来的报文段，那么这个应答报文是啥呢？实际上，TCP 就是通过确认应答(ACK) 来实现可靠的数据传输，当主机 A将数据发出之后会等待主机 B 的响应。如果有确认应答(ACK)，说明数据已经成功到达。反之，则数据很可能会丢失。</p><p>如下图所示，如果在一定时间内主机 A 没有等到确认应答，则认为主机 B 发送的报文段已经丢失，并进行重发。</p><p><a href="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118164248550.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118164248550.png" alt="image-20231118164248550" class="lazyload" data-proofer-ignore></a></p><p>主机 A 给主机 B 的响应可能由于网络抖动等原因无法到达，那么在经过特定的时间间隔后，主机 A 将重新发送报文段。</p><p>主机 A 没有收到主机 B 的应答报文，可能是因为报文段在主机 B 在发送给主机 A 的过程中丢失。</p><p><a href="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118164335222.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118164335222.png" alt="image-20231118164335222" class="lazyload" data-proofer-ignore></a></p><p>如上图所示，由主机 B 返回的确认应答，由于网络拥堵等原因在传送的过程中丢失，并没有到达主机 A。主机 A 会等待一段时间，如果在这段时间内主机 A 仍没有等到主机 B 的响应，那么主机 A 会重新发送报文段。</p><p>要辩证的看待问题，如果主机 A 没有收到应答报文，不一定是主机 A 发送的报文段丢失，还有可能是主机 B 发送的应答报文丢失，还可能是主机 B 没有发送应答报文，所以没有收到报文的情况有很多种。</p><p>那么现在就存在一个问题，如果主机 A 给主机 B 发送了一个报文段后，主机 B 接受到报文段发送响应，此刻由于网络原因，这个报文段并未到达，等到一段时间后主机 A 重新发送报文段，然后此时主机 B 发送的响应在主机 A 第二次发送后失序到达主机 A，那么主机 A 应该如何处理呢？</p><p><a href="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118164417899.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118164417899.png" alt="image-20231118164417899" class="lazyload" data-proofer-ignore></a></p><p>TCP RFC 并未为此做任何规定，也就是说，我们可以自己决定如何处理失序到达的报文段。一般处理方式有两种</p><ol><li>接收方立刻丢弃失序的报文段。<li>接收方接受时许到达的报文段，并等待后续的报文段。</ol><p>一般来说通常采取的做法是第二种。</p><h3 id="传输控制"><span class="mr-2"><strong>传输控制</strong></span><a href="#传输控制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="利用窗口控制提高速度"><span class="mr-2"><strong>利用窗口控制提高速度</strong></span><a href="#利用窗口控制提高速度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>前面我们介绍了 TCP 是以数据段的形式进行发送，如果经过一段时间内主机 A 等不到主机 B 的响应，主机 A 就会重新发送报文段，接受到主机 B 的响应，再会继续发送后面的报文段，我们现在看到，这一问一答的方式还存在许多意外条件，比如响应未收到、等待响应等，那么对崇尚性能的互联网来说，这种方式的性能应该不会很高。</p><p><a href="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118164553763.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118164553763.png" alt="image-20231118164553763" class="lazyload" data-proofer-ignore></a></p><p>那么如何提升性能呢？</p><p>为了解决这个问题，TCP 引入了<strong>窗口</strong>这个概念，这个窗口大家可以把它理解为发送期，就是说在这个窗口（发送期）中，通信双方可以任意发送数据，也就是说引入窗口后，从之前单次发送变成了一段时间内的多次报文发送。所以，即使在往返时间较长、频次很多的情况下，它也能控制网络性能的下降，如下图所示</p><p><a href="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118164832089.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118164832089.png" alt="image-20231118164832089" class="lazyload" data-proofer-ignore></a></p><p>我们之前每次请求发送都是以报文段的形式进行的，引入窗口后，每次请求都可以发送多个报文段，也就是说一个窗口可以发送多个报文段。窗口大小就是指无需等待确认应答就可以继续发送报文段的最大值。</p><p>在这个窗口机制中，大量使用了缓冲区的实现方式，通过对多个段同时进行确认应答的功能。</p><p>如下图所示，发送报文段中高亮部分即是我们提到的窗口，在窗口内，即是没有收到确认应答也可以把请求发送出去。不过，在整个窗口的确认应答没有到达之前，如果部分报文段丢失，那么主机 A 将仍会重传。为此，主机 A 需要设置缓存来保留这些需要重传的报文段，直到收到他们的确认应答。</p><p><a href="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118164933422.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118164933422.png" alt="image-20231118164933422" class="lazyload" data-proofer-ignore></a></p><p>在滑动窗口以外的部分是尚未发送的报文段和已经接受到的报文段，如果报文段已经收到确认则不可进行重发，此时报文段就可以从缓冲区中清除。</p><p>在收到确认的情况下，会将窗口滑动到确认应答中确认号的位置，如上图所示，这样可以顺序的将多个段同时发送，用以提高通信性能，这种窗口也叫做 滑动窗口(Sliding window)。</p><h4 id="窗口控制和重发"><span class="mr-2"><strong>窗口控制和重发</strong></span><a href="#窗口控制和重发" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>报文段的发送和接收，必然伴随着报文段的丢失和重发，窗口也是同样如此，如果在窗口中报文段发送过程中出现丢失怎么办？</p><p>首先我们先考虑确认应答没有返回的情况。在这种情况下，主机 A 发送的报文段到达主机 B，是不需要再进行重发的。这和单个报文段的发送不一样，如果发送单个报文段，即使确认应答没有返回，也要进行重发。</p><p><a href="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118165053955.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118165053955.png" alt="image-20231118165053955" class="lazyload" data-proofer-ignore></a></p><p><strong>窗口在一定程度上比较大时，即使有少部分确认应答的丢失，也不会重新发送报文段。</strong></p><p>我们知道，如果在某个情况下由于发送的报文段丢失，导致接受主机未收到请求，或者主机返回的响应未到达客户端的话，会经过一段时间重传报文。那么在使用窗口的情况下，报文段丢失会怎么样呢？</p><p>如下图所示，报文段 0 - 999 丢失后，但是主机 A 并不会等待，主机 A 会继续发送余下的报文段，主机 B 发送的确认应答却一直是 1000，同一个确认号的应答报文会被持续不断的返回，如果发送端主机在连续 3 次收到同一个确认应答后，就会将其所对应的数据重发，这种机制要比之前提到的超时重发更加高效，这种机制也被称为高速重发控制。这种重发的确认应答也被称为<strong>冗余 ACK(响应)</strong>。</p><p><a href="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118165253570.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118165253570.png" alt="image-20231118165253570" class="lazyload" data-proofer-ignore></a></p><p>主机 B 在没有接收到自己期望序列号的报文段时，会对之前收到的数据进行确认应答。发送端则一旦收到某个确认应答后，又连续三次收到同样的确认应答，那么就会认为报文段已经丢失。需要进行重发。使用这种机制可以提供更为快速的重发服务。</p><h3 id="流量控制"><span class="mr-2"><strong>流量控制</strong></span><a href="#流量控制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们知道，在每个 TCP 连接的一侧主机都会有一个 socket 缓冲区，缓冲区会为每个连接设置接收缓存和发送缓存，当 TCP 建立连接后，从应用程序产生的数据就会到达接收方的接收缓冲区中，接收方的应用程序并不一定会马上读取缓冲区的数据，它需要等待操作系统分配时间片。如果此时发送方的应用程序产生数据过快，而接收方读取接受缓冲区的数据相对较慢的话，那么接收方中缓冲区的数据将会溢出，导致数据丢失。</p><p>但是还好，TCP 有<strong>流量控制服务(flow-control service)</strong>机制用于消除缓冲区溢出的情况。流量控制是一个速度匹配服务，即发送方的发送速率与接受方应用程序的读取速率相匹配。</p><p>TCP 通过使用一个<strong>接收窗口(receive window)</strong> 的变量来提供流量控制。接收窗口会给发送方一个指示到底还有多少可用的缓存空间。发送端会根据接收端的实际接受能力来控制发送的数据量。</p><p>接收端向发送端通知自己可以接收数据量的大小，发送端会发送不超过这个限度的数据，这个大小限度就是窗口大小，还记得 TCP 的首部么，有一个接收窗口，我们上面聊的时候说这个字段用于流量控制。它用于指示接收方能够接受的字节数量。</p><p>那么如何实时知道接收方能够接收的数据量大小呢？</p><p>发送端主机会定期发送一个<strong>窗口探测包</strong>，这个包用于探测接收端主机是否还能够接受数据，当接收端的缓冲区一旦面临数据溢出的风险时，窗口大小的值也随之被设置为一个更小的值通知发送端，从而控制数据发送量。</p><p>下面是一个流量控制示意图</p><p><a href="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118165451690.png" class="popup img-link "><img data-src="/assets/blog_res/2023-10-29-NetWorkProtocol2.assets/image-20231118165451690.png" alt="image-20231118165451690" class="lazyload" data-proofer-ignore></a></p><p>发送端主机根据接收端主机的窗口大小进行流量控制。由此也可以防止发送端主机一次发送过大数据导致接收端主机无法处理。</p><p>如上图所示，当主机 B 收到报文段 2000 - 2999 之后缓冲区已满，不得不暂时停止接收数据。然后主机 A 发送窗口探测包，窗口探测包非常小仅仅一个字节。然后主机 B 更新缓冲区接收窗口大小并发送窗口更新通知给主机 A，然后主机 A 再继续发送报文段。</p><p>在上面的发送过程中，窗口更新通知可能会丢失，一旦丢失发送端就不会发送数据，所以窗口探测包会随机发送，以避免这种情况发生。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/'>计算机网络</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E5%AD%A6%E4%B9%A0/" class="post-tag no-text-decoration" >学习</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE(%E4%BA%8C)%20-%20YKFire&url=%2Fposts%2FNetWorkProtocol2%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE(%E4%BA%8C)%20-%20YKFire&u=%2Fposts%2FNetWorkProtocol2%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FNetWorkProtocol2%2F&text=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE(%E4%BA%8C)%20-%20YKFire" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/ApplyProtocol2/">计算机网络应用层协议(二)</a><li><a href="/posts/ApplyProtocol/">计算机网络应用层协议(一)</a><li><a href="/posts/NetworkOne/">计算机网络发展史(一)</a><li><a href="/posts/NetworkTwo/">计算机网络发展史(二)</a><li><a href="/posts/NetworkThree/">计算机网络发展史(三)</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a> <a class="post-tag" href="/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/">职业规划</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/surroundedByAlgorithms/"><div class="card-body"> <em class="small" data-ts="1700983740" data-df="YYYY/MM/DD" > 2023/11/26 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>完蛋！我被算法包围了</h3><div class="text-muted small"><p> 算法在日常生活的应用 算法听上去很复杂，离我们很遥远。但是以下 10 种算法广泛用于我们的日常生活，包括互联网搜索引擎、社交网络、WiFi、手机甚至卫星。 以下是主宰我们世界的十种算法： 01 排序 我们学习算法一般都是从排序算法开始的，比如冒泡排序、快排序、归并排序、堆排序等。 笔者曾经做过的一个大批量对账系统，就是在第一步使用归并外排序（External MergeSort...</p></div></div></a></div><div class="card"> <a href="/posts/MyFirstBlog/"><div class="card-body"> <em class="small" data-ts="1662124620" data-df="YYYY/MM/DD" > 2022/09/02 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>我的第一篇博客！</h3><div class="text-muted small"><p> 我的第一篇博客！ 这里可以放代码片段噢～ //代码片段 int main(){ hello world; }</p></div></div></a></div><div class="card"> <a href="/posts/List/"><div class="card-body"> <em class="small" data-ts="1662694200" data-df="YYYY/MM/DD" > 2022/09/09 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>数据结构--链表</h3><div class="text-muted small"><p> 数据结构–链表 一、链表简介 什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域，一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思） 链接的入口节点称为链表的头结点也就是head 链表的两种操作方法：①直接使用原来的链表进行操作 ②设置一个虚拟头结点进行操作 一般设置一个虚拟头结点来操作...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/NetWorkProtocol/" class="btn btn-outline-primary" prompt="上一篇"><p>计算机网络传输层协议(一)</p></a> <a href="/posts/NetWorkProtocol3/" class="btn btn-outline-primary" prompt="下一篇"><p>计算机网络传输层协议(三)</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a> <a class="post-tag" href="/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/">职业规划</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/username">YKFire</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
