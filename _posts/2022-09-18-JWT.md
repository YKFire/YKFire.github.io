---
title: JWT介绍
date: 2022-09-18 19:30:00 +0800
categories: [技术科普]
tags: [学习]
pin: true
author: YKFire

toc: true
comments: true

math: false
mermaid: true

typora-root-url: ../../YKFire.github.io

---

# JWT介绍 

## 一、JWT简介

​	JWT，全名：Json Web Token，是一种开放标准， 它定义了一种以紧凑和自包含的方法，用于在双方之间安全地传输编码为 JSON 对象的信息。

​	因此，简单来说，**它是 JSON 格式的加密字符串**，其中包含敏感信息，它使我们能够验证不同服务间的发送者。

## 二、JWT的使用场景

- 授权： 这是使用 JWT 最常见的场景。JWT 用于授权而非身份验证。通过**身份验证**，我们验证用户名和密码是否有效，并将用户登录到系统中。通过**授权**，我们可以**验证发送到服务器的请求是否属于通过身份验证登录的用户**，从而可以授予该用户访问系统的权限，继而批准该用户使用获得的 token 访问路由、服务和资源
- 信息交换：SON Web Token 是在双方之间安全地传输信息的一种好方法。因为 JWT 可以被签名（例如，使用公钥/私钥对），所以使您能确保发送方是他们所声称的那一方。此外，由于签名是使用 Header 和 Payload 计算的，因此还使您能验证发送的内容没有被篡改

## 三、JWT与Session Id的比较

### 1、小型WEB应用程序

#### 1.Session Id实现

​	在传统的 Web 应用程序中，我们使用 Session 来授权用户，当用户登录到应用程序后，我们会为该用户分配一个唯一的 Session Id。我们将此 Session Id 保存在用户浏览器的安全 cookie 中和服务器的内存中。我们对每个请求都使用相同的会话，以便服务器知道该用户已通过身份验证。对于每个请求，cookie 中的 Session Id 都会与服务器内存中的 Session Id 作匹配，以验证用户是否被授权。

![image-20220918195001955](/assets/blog_res/2022-09-18-JWT.assets/image-20220918195001955.png)

#### 2.JWT实现

​	在 JWT 实现中，我们使用 JWT 授权用户，当用户登录到应用程序后，就会为每个通过身份验证的用户生成一个唯一的 JWT。我们将该 token 保存在浏览器的 local storage 或者 cookie 中，而不会在服务器端保存任何内容。对于每个请求，该 token 都会被发送到服务器进行解密和验证，以核实该用户是否已授权，不管以何种方式篡改了 token 都会被拒绝。

![image-20220918195027843](/assets/blog_res/2022-09-18-JWT.assets/image-20220918195027843.png)

**这种实现对于小型站点来说很好，仅仅因为我们不再存储 Session Id，从而通过减少服务器的负载，我们已经从 JWT 中看到了一些好处**

### 2、高级WEB应用程序

#### 1.Session Id实现

![image-20220918195117351](/assets/blog_res/2022-09-18-JWT.assets/image-20220918195117351.png)

​	当我们的WEB应用逐渐火热，我们需要有一台连接到负载均衡器的新服务器，以便基于流量和可用性在 Web 服务器之间导航流量。这种实现给我们带来了一个新的问题，如下所示：

如果*用户 1* 登录到了*服务器 1*，那么*服务器 1* 已经将 session 保存在其内存中，当*用户 1* 发出另一个请求并且负载均衡器将该请求重定向到了*服务器 2*，而*服务器 2* 没有保存该 session 信息，这时会发生什么情况？

*用户将被认为已退出应用程序并被要求再次登录*，这不是一个好的用户体验。通常，我们解决这个问题的方法是引入缓存：

![image-20220918195217382](/assets/blog_res/2022-09-18-JWT.assets/image-20220918195217382.png)

​	现在，所有的 Session 也将同时保存在缓存中，因此任何一台服务器都可以检查该 Session 是否存在，并可以利用它来验证用户并授予他们对应用程序的访问权限。

尽管缓存解决了我们的问题，但是在生产环境中，这种解决方案有着昂贵的成本：

- 需要大量的 RAM、CPU、存储来跟踪所有这些会话和平稳地处理请求
- 需要维护缓存，以确保没有幽灵会话或无效会话
- 万一某台服务器崩溃，所有未与缓存同步的会话都会丢失
- 使用户无效更复杂
- 托管成本高

#### 2.JWT实现

​	让我们来看看如何通过 JWT 实现来处理相同的情况。

​	不同于在 Cookie 中使用 Session Id 与服务器内存中的 Session 作匹配；我们可以使用 JWT 来代替它。此时，当用户登录到我们的应用程序时，服务器将不会生成 Session Id 并将其保存在内存中，而是会创建一个 JWT token，并对其进行编码和序列化，然后使用自己的加密机制对其进行签名。通过这种方式，服务将知道一旦对它做了变更或篡改，便将其变为无效。由于通过服务器的加密机制对其进行了签名，所以这是可以被检验的。

![image-20220918195258357](/assets/blog_res/2022-09-18-JWT.assets/image-20220918195258357.png)

​	使用 JWT 可以更容易地管理可伸缩性，因为我们不需要服务器来处理任何会话检查或缓存检查。请求可以转发到负载均衡器为其分配的任一服务器，而无需担心会话的可用性。**万一某台服务器宕机，所有的 token 将仍然有效，因为所有服务器上的加密机制是一样的。**

#### 3.JWT与Session Id的区别总结

**JWT：**

- 服务器上不保存任何东西，JWT 存储于客户端中
- 由服务器加密和签名
- token 包含用户的所有信息
- 所有信息都存储于 token 本身中
- 易于缩放

![image-20220918195537550](/assets/blog_res/2022-09-18-JWT.assets/image-20220918195537550.png)

**Session Id**

- Session Id 保存于服务器和客户端中
- 加密并签名
- Session Id 是对用户的引用
- 服务器需要查找用户并进行必要的检查
- 难以缩放

![image-20220918195612107](/assets/blog_res/2022-09-18-JWT.assets/image-20220918195612107.png)

## 四、JWT结构

JSON Web Token 由三部分组成，以点（.）分隔，分别是：

- Header（标头）
- Payload（有效负载）
- Signature（签名）

因此，JWT 通常如下所示：

```
xxxxxx.yyyyyyy.zzzzzzzz
```